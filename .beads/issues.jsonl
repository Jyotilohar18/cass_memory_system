{"id":"cass_memory_system-0ew","title":"Phase 2: Core Pipeline + Anti-Patterns","description":"# EPIC: Core Pipeline + Anti-Patterns\n\n## Purpose\nImplement the full diary → reflect → curate pipeline with anti-pattern learning.\nThis phase makes the system actually learn from agent sessions.\n\n## Background \u0026 Reasoning\nThe ACE paper's key insight is that LLM-generated rules can \"collapse\" if the LLM \nrewrites the entire playbook. The solution: deterministic curation that only applies\ndelta operations (add/helpful/harmful/replace/deprecate).\n\nThis phase also introduces anti-pattern inversion - when a bullet proves harmful \nmultiple times, instead of deleting it, we invert it to \"DON'T do X\" and mark it\nas kind=anti_pattern. This captures negative learnings.\n\n## Priority Features (from ROI analysis)\n- P3: Anti-pattern inversion (8× impact)\n- P5: Maturity states candidate/established/proven (5× impact)\n- P6: Cascading config global + .cass/ repo-level (4× impact)\n- P8: Forget command + toxic bullet log (3× impact)\n- P11: Evidence-count gate pre-LLM validation (8× impact)\n- P13: Doctor command system health (5× DX impact)\n\n## Key Deliverables\n1. `cass-memory diary \u003csession\u003e` - Generate structured diary from session\n2. `cass-memory reflect --days N` - Run full reflection cycle\n3. `cass-memory curate` - Apply deltas deterministically\n4. `cass-memory mark \u003cid\u003e --helpful/--harmful` - Record feedback\n5. `cass-memory forget \u003cid\u003e` - Permanently block toxic patterns\n6. `cass-memory doctor` - System health check\n\n## Critical Algorithms\n1. **Evidence-count gate**: Before sending to LLM validator, check if session\n   success/failure counts provide enough signal. If 5+ successes with 0 failures,\n   auto-accept. If 3+ failures with 0 successes, auto-reject.\n\n2. **Anti-pattern inversion**: When harmfulCount crosses threshold, transform\n   bullet from \"Use X for Y\" to \"AVOID: X causes Z problems when doing Y\"\n\n3. **Maturity state machine**:\n   - draft: \u003c3 feedback events\n   - established: 3-10 helpful, \u003c30% harmful\n   - proven: 10+ helpful, \u003c10% harmful ratio\n   - retired: deprecated OR 30%+ harmful\n\n## Dependencies\n- Requires Phase 1 completion (types, config, cass wrapper)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-07T16:16:41.288609-05:00","updated_at":"2025-12-07T16:16:41.288609-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew","depends_on_id":"cass_memory_system-5eh","type":"blocks","created_at":"2025-12-07T16:23:18.428702-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-0ew.1","title":"Diary Generation: cass-memory diary (Reflector Input)","description":"# Feature: Diary Generation Command\n\n## Purpose\nThe \"Working Memory\" layer: transform raw agent sessions into structured diary\nentries. These diaries become input to the Reflector for delta extraction.\n\n## Usage\n```bash\ncass-memory diary ~/.claude/sessions/session-abc.jsonl --json\ncass-memory diary \u003csession-path\u003e [--enrich] [--save]\n```\n\n## Process Flow\n```\n1. Load session via cass export (markdown format)\n2. Apply secret sanitization\n3. Run LLM extraction (DiaryExtractionSchema)\n4. If --enrich: Query cass for related sessions (cross-agent)\n5. Save to ~/.cass-memory/diary/{id}.json\n6. Output result\n```\n\n## DiaryEntry Fields (from LLM)\n- **status**: success | failure | mixed\n- **accomplishments**: What was completed (SPECIFIC - file names, functions)\n- **decisions**: Design choices with rationale\n- **challenges**: Problems encountered, errors, blockers\n- **preferences**: User style revelations\n- **keyLearnings**: Reusable insights\n\n## Cross-Agent Enrichment (--enrich)\n```typescript\nasync function enrichDiary(diary: DiaryEntry, config: Config): Promise\u003cDiaryEntry\u003e {\n  // Extract keywords from diary content\n  const keywords = [\n    ...diary.keyLearnings,\n    ...diary.challenges.map(extractKeywords).flat()\n  ].slice(0, 5);\n  \n  // Query cass for related sessions from OTHER agents\n  const related = await safeCassSearch(keywords.join(\" \"), {\n    limit: 5,\n    days: 30,\n    // Exclude the same agent\n    agent: ALL_AGENTS.filter(a =\u003e a !== diary.agent)\n  }, config.cassPath);\n  \n  diary.relatedSessions = related.map(h =\u003e ({\n    sessionPath: h.source_path,\n    agent: h.agent,\n    relevanceScore: h.score,\n    snippet: h.snippet\n  }));\n  \n  return diary;\n}\n```\n\n## LLM Prompt (Key Instructions)\n```\nBe SPECIFIC and ACTIONABLE. Avoid generic statements.\nInclude specific:\n- File names and paths\n- Function/class/component names\n- Error messages and stack traces\n- Commands run\n- Tools used\n\nIf the session lacks information for a field, provide an empty array.\n```\n\n## Output\n```json\n{\n  \"id\": \"diary-abc123\",\n  \"sessionPath\": \"~/.claude/sessions/session-abc.jsonl\",\n  \"timestamp\": \"2025-12-07T10:30:00Z\",\n  \"agent\": \"claude\",\n  \"workspace\": \"/Users/x/projects/myapp\",\n  \"status\": \"success\",\n  \"accomplishments\": [\n    \"Fixed authentication timeout by increasing session TTL in config.ts:42\",\n    \"Added retry logic to AuthService.refresh() method\"\n  ],\n  \"decisions\": [\n    \"Chose 7200s TTL to match expected user session duration\"\n  ],\n  \"challenges\": [\n    \"Initial confusion about which config file controls TTL\"\n  ],\n  \"preferences\": [\n    \"User prefers explicit error messages over silent failures\"\n  ],\n  \"keyLearnings\": [\n    \"Auth timeout issues are usually config-related, not code bugs\"\n  ],\n  \"relatedSessions\": [...],\n  \"tags\": [\"auth\", \"timeout\", \"config\"],\n  \"searchAnchors\": [\"authentication timeout\", \"session TTL\", \"AuthService\"]\n}\n```\n\n## Dependency\n- Requires Phase 1 completion (LLM, cass wrapper, sanitization)","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:21:02.394292-05:00","updated_at":"2025-12-07T16:21:02.394292-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew.1","depends_on_id":"cass_memory_system-0ew","type":"parent-child","created_at":"2025-12-07T16:21:02.39531-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.1","depends_on_id":"cass_memory_system-5eh.9","type":"blocks","created_at":"2025-12-07T16:23:18.50333-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.1","depends_on_id":"cass_memory_system-5eh.4","type":"blocks","created_at":"2025-12-07T16:23:18.579027-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.1","depends_on_id":"cass_memory_system-5eh.5","type":"blocks","created_at":"2025-12-07T16:23:18.645627-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-0ew.2","title":"Mark Command: cass-memory mark (Feedback Recording)","description":"# Feature: Mark Command\n\n## Purpose\nRecord bullet usage feedback. This is how the playbook learns:\n- Mark helpful when a rule helps you succeed\n- Mark harmful when following a rule causes problems\n\n## Usage\n```bash\ncass-memory mark b-abc123 --helpful\ncass-memory mark b-abc123 --harmful --reason \"Caused test failures\"\ncass-memory mark b-abc123 --helpful --session ~/.claude/sessions/abc.jsonl\n```\n\n## Implementation\n```typescript\nasync function markCommand(\n  bulletId: string,\n  flags: { helpful?: boolean; harmful?: boolean; reason?: string; session?: string }\n): Promise\u003cvoid\u003e {\n  const config = await loadConfig();\n  const playbook = await loadMergedPlaybook(config);\n  \n  // Find bullet\n  const bullet = findBullet(playbook, bulletId);\n  if (!bullet) {\n    error(`Bullet not found: ${bulletId}`);\n    process.exit(1);\n  }\n  \n  // Create feedback event WITH TIMESTAMP (P1 - critical for decay)\n  const event: FeedbackEvent = {\n    type: flags.helpful ? \"helpful\" : \"harmful\",\n    timestamp: now(),\n    sessionPath: flags.session,\n    reason: flags.reason\n  };\n  \n  // Add event to bullet\n  bullet.feedbackEvents.push(event);\n  \n  // Update legacy counts (for backwards compatibility)\n  if (flags.helpful) bullet.helpfulCount++;\n  else bullet.harmfulCount++;\n  \n  // Update timestamps\n  bullet.updatedAt = now();\n  \n  // Recalculate state\n  bullet.state = calculateMaturityState(bullet, config);\n  \n  // Save playbook\n  await savePlaybook(playbook, config.playbookPath);\n  \n  // Also log to usage.jsonl for audit trail\n  await appendUsageLog({\n    bulletId,\n    event,\n    effectiveScoreAfter: getEffectiveScore(bullet, config)\n  });\n  \n  output({\n    success: true,\n    bulletId,\n    event,\n    newState: bullet.state,\n    effectiveScore: getEffectiveScore(bullet, config)\n  }, formatMarkResult, flags);\n}\n```\n\n## Usage Log Format\n```\n~/.cass-memory/usage.jsonl\n{\"bulletId\":\"b-abc123\",\"type\":\"helpful\",\"timestamp\":\"2025-12-07T10:30:00Z\",\"session\":\"...\"}\n{\"bulletId\":\"b-def456\",\"type\":\"harmful\",\"timestamp\":\"2025-12-07T11:00:00Z\",\"reason\":\"...\"}\n```\n\n## State Transitions After Mark\n- If new harmful feedback pushes ratio \u003e 30%: state → \"retired\"\n- If helpful feedback reaches 10 with ratio \u003c 10%: state → \"proven\"\n- Automatic decay recalculation happens on every read\n\n## Output\n```json\n{\n  \"success\": true,\n  \"bulletId\": \"b-abc123\",\n  \"event\": {\n    \"type\": \"helpful\",\n    \"timestamp\": \"2025-12-07T10:30:00Z\"\n  },\n  \"newState\": \"proven\",\n  \"effectiveScore\": 15.2\n}\n```","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:21:02.639637-05:00","updated_at":"2025-12-07T16:21:02.639637-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew.2","depends_on_id":"cass_memory_system-0ew","type":"parent-child","created_at":"2025-12-07T16:21:02.640418-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.2","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:23:18.720967-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.2","depends_on_id":"cass_memory_system-5eh.6","type":"blocks","created_at":"2025-12-07T16:23:18.796945-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-0ew.3","title":"Reflector Pipeline: src/reflect.ts (Delta Extraction)","description":"# Feature: Reflector Pipeline\n\n## Purpose\nThe \"Reflector\" phase of ACE: extract reusable lessons (deltas) from diary entries.\nThis is where the LLM analyzes sessions and proposes playbook changes.\n\n## Key Innovation: Multi-Iteration Reflection\nInstead of one pass, run the reflector multiple times (configurable 1-3):\n- Iteration 0: General insights\n- Iteration 1: Focus on missed patterns\n- Iteration 2: Focus on edge cases\n\nThis catches insights a single pass might miss.\n\n## Implementation\n```typescript\nasync function reflectOnSession(\n  diary: DiaryEntry,\n  playbook: Playbook,\n  config: Config\n): Promise\u003cDelta[]\u003e {\n  const allDeltas: Delta[] = [];\n  \n  // Get cass history for cross-referencing\n  const cassHistory = await getCassHistoryForDiary(diary, config);\n  \n  // Format existing bullets for prompt\n  const existingBullets = formatBulletsForPrompt(playbook.bullets);\n  \n  // Multi-iteration reflection\n  for (let i = 0; i \u003c config.maxReflectorIterations; i++) {\n    const iterationNote = i \u003e 0\n      ? `This is iteration ${i + 1}. Focus on insights you may have missed.`\n      : \"\";\n    \n    const output = await runReflector(\n      ReflectorOutputSchema,\n      diary,\n      existingBullets,\n      cassHistory,\n      i,\n      config\n    );\n    \n    // Convert raw output to typed deltas\n    const deltas = output.deltas.map(d =\u003e convertToTypedDelta(d, diary.sessionPath));\n    \n    // Deduplicate against previous iterations\n    const newDeltas = deduplicateDeltas(deltas, allDeltas);\n    allDeltas.push(...newDeltas);\n    \n    // Early exit if no new insights\n    if (newDeltas.length === 0) break;\n  }\n  \n  return allDeltas;\n}\n```\n\n## Delta Types Extracted\n1. **add**: New insight not covered by existing bullets\n2. **helpful**: Existing bullet proved useful\n3. **harmful**: Existing bullet caused problems\n4. **replace**: Existing bullet needs updated wording\n5. **deprecate**: Existing bullet is outdated\n\n## Prompt Guidelines (Critical for Quality)\n```\nGuidelines for the LLM:\n- Be SPECIFIC. Bad: \"Write tests\". Good: \"For React hooks, test effects separately with renderHook\"\n- Include concrete examples, file patterns, command flags when relevant\n- Only propose deltas for genuinely reusable insights\n- Consider if a bullet would help a DIFFERENT agent on a similar problem\n- Maximum 20 deltas per reflection\n```\n\n## Deduplication Logic\n```typescript\nfunction deduplicateDeltas(newDeltas: Delta[], existing: Delta[]): Delta[] {\n  return newDeltas.filter(d =\u003e {\n    if (d.type === \"add\") {\n      // Check content similarity\n      return !existing.some(e =\u003e\n        e.type === \"add\" \u0026\u0026 jaccardSimilarity(d.bullet.content, e.bullet.content) \u003e 0.8\n      );\n    }\n    // For helpful/harmful, allow multiple from same session\n    return true;\n  });\n}\n```","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:21:03.831701-05:00","updated_at":"2025-12-07T16:21:03.831701-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew.3","depends_on_id":"cass_memory_system-0ew","type":"parent-child","created_at":"2025-12-07T16:21:03.832365-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.3","depends_on_id":"cass_memory_system-0ew.1","type":"blocks","created_at":"2025-12-07T16:23:18.869954-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.3","depends_on_id":"cass_memory_system-5eh.9","type":"blocks","created_at":"2025-12-07T16:23:18.947072-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-0ew.4","title":"Evidence-Count Gate: Pre-LLM Validator (P11)","description":"# Feature: Evidence-Count Gate (P11)\n\n## Purpose\nBEFORE sending a proposed rule to the LLM validator, check if historical\nsession success/failure counts provide enough signal to auto-accept or\nauto-reject. This saves LLM tokens and speeds up the pipeline.\n\n## The Insight\nIf 5+ sessions SUCCEEDED with a pattern and 0 FAILED, we don't need an LLM\nto tell us it's valid. Conversely, if 3+ sessions FAILED and 0 SUCCEEDED,\nwe can auto-reject without burning tokens.\n\n## Implementation\n```typescript\ninterface EvidenceGateResult {\n  action: \"auto-accept\" | \"auto-reject\" | \"needs-llm\";\n  confidence: number;\n  successCount: number;\n  failureCount: number;\n  relevantSessions: CassHit[];\n}\n\nasync function evidenceCountGate(\n  proposedRule: string,\n  config: Config\n): Promise\u003cEvidenceGateResult\u003e {\n  // 1. Extract keywords from proposed rule\n  const keywords = extractKeywords(proposedRule);\n  \n  // 2. Search cass for sessions mentioning this pattern\n  const hits = await safeCassSearch(keywords.join(\" \"), {\n    limit: 20,\n    days: config.validationLookbackDays\n  }, config.cassPath);\n  \n  // 3. Classify sessions by outcome (success/failure)\n  let successCount = 0;\n  let failureCount = 0;\n  \n  for (const hit of hits) {\n    const outcome = classifySessionOutcome(hit);\n    if (outcome === \"success\") successCount++;\n    else if (outcome === \"failure\") failureCount++;\n  }\n  \n  // 4. Apply gates\n  // Strong success signal: auto-accept\n  if (successCount \u003e= 5 \u0026\u0026 failureCount === 0) {\n    return {\n      action: \"auto-accept\",\n      confidence: 0.95,\n      successCount,\n      failureCount,\n      relevantSessions: hits\n    };\n  }\n  \n  // Strong failure signal: auto-reject\n  if (failureCount \u003e= 3 \u0026\u0026 successCount === 0) {\n    return {\n      action: \"auto-reject\",\n      confidence: 0.9,\n      successCount,\n      failureCount,\n      relevantSessions: hits\n    };\n  }\n  \n  // Ambiguous: needs LLM analysis\n  return {\n    action: \"needs-llm\",\n    confidence: 0.5,\n    successCount,\n    failureCount,\n    relevantSessions: hits\n  };\n}\n```\n\n## Session Outcome Classification\n```typescript\nfunction classifySessionOutcome(hit: CassHit): \"success\" | \"failure\" | \"unknown\" {\n  const snippet = hit.snippet.toLowerCase();\n  \n  // Success indicators\n  if (snippet.includes(\"fixed\") || \n      snippet.includes(\"resolved\") ||\n      snippet.includes(\"completed\") ||\n      snippet.includes(\"works now\")) {\n    return \"success\";\n  }\n  \n  // Failure indicators\n  if (snippet.includes(\"failed\") ||\n      snippet.includes(\"error\") ||\n      snippet.includes(\"broken\") ||\n      snippet.includes(\"didn't work\")) {\n    return \"failure\";\n  }\n  \n  return \"unknown\";\n}\n```\n\n## Integration with Validator\n```typescript\nasync function validateRule(\n  proposedRule: string,\n  config: Config\n): Promise\u003cValidationResult\u003e {\n  // 1. Check evidence gate first\n  const gateResult = await evidenceCountGate(proposedRule, config);\n  \n  if (gateResult.action === \"auto-accept\") {\n    return {\n      valid: true,\n      reason: `Auto-accepted: ${gateResult.successCount} successes, 0 failures`,\n      confidence: gateResult.confidence\n    };\n  }\n  \n  if (gateResult.action === \"auto-reject\") {\n    return {\n      valid: false,\n      reason: `Auto-rejected: ${gateResult.failureCount} failures, 0 successes`,\n      confidence: gateResult.confidence\n    };\n  }\n  \n  // 2. Fall through to LLM validation\n  return runLLMValidator(proposedRule, gateResult.relevantSessions, config);\n}\n```\n\n## ROI\n- Saves LLM tokens on clear-cut cases\n- Faster pipeline (no network call for auto-decisions)\n- More transparent reasoning (explicit success/failure counts)","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:22:32.925118-05:00","updated_at":"2025-12-07T16:22:32.925118-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew.4","depends_on_id":"cass_memory_system-0ew","type":"parent-child","created_at":"2025-12-07T16:22:32.926095-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.4","depends_on_id":"cass_memory_system-5eh.4","type":"blocks","created_at":"2025-12-07T16:23:19.037002-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-0ew.5","title":"Curator Pipeline: Deterministic Delta Application (ACE Core)","description":"# Feature: Curator Pipeline (Deterministic Delta Application)\n\n## Purpose\nThe \"Curator\" phase of ACE: apply validated deltas to the playbook\nDETERMINISTICALLY. No LLM rewriting of the playbook - only precise\ndelta operations. This prevents \"context collapse\" where the LLM\nrewrites everything and loses accumulated knowledge.\n\n## Critical Principle\nThe ACE paper's key insight: if you let the LLM rewrite the entire\nplaybook, information is lost through summarization and compression.\nInstead, the curator only applies specific operations:\n- Add new bullets\n- Increment helpful/harmful counts\n- Replace specific content\n- Deprecate specific bullets\n- Merge similar bullets\n\n## Implementation\n```typescript\nfunction curatePlaybook(\n  playbook: Playbook,\n  deltas: Delta[],\n  config: Config\n): { playbook: Playbook; applied: number; skipped: number } {\n  let applied = 0;\n  let skipped = 0;\n  \n  for (const delta of deltas) {\n    switch (delta.type) {\n      case \"add\":\n        // Check for duplicates BEFORE adding\n        if (isDuplicate(delta.bullet.content, playbook.bullets, config.dedupSimilarityThreshold)) {\n          // Merge into existing instead of adding\n          const existing = findSimilarBullet(delta.bullet.content, playbook.bullets);\n          if (existing) {\n            existing.feedbackEvents.push({\n              type: \"helpful\",\n              timestamp: now(),\n              sessionPath: delta.sourceSession\n            });\n            existing.helpfulCount++;\n          }\n          skipped++;\n          continue;\n        }\n        \n        // Add new bullet\n        const newBullet = createBullet(delta.bullet, delta.sourceSession);\n        playbook.bullets.push(newBullet);\n        applied++;\n        break;\n        \n      case \"helpful\":\n      case \"harmful\":\n        const bullet = findBullet(playbook, delta.bulletId);\n        if (bullet) {\n          bullet.feedbackEvents.push({\n            type: delta.type,\n            timestamp: now(),\n            sessionPath: delta.sourceSession,\n            reason: delta.type === \"harmful\" ? delta.reason : undefined\n          });\n          if (delta.type === \"helpful\") bullet.helpfulCount++;\n          else bullet.harmfulCount++;\n          bullet.updatedAt = now();\n          applied++;\n        } else {\n          skipped++;\n        }\n        break;\n        \n      case \"replace\":\n        const toReplace = findBullet(playbook, delta.bulletId);\n        if (toReplace) {\n          toReplace.content = delta.newContent;\n          toReplace.updatedAt = now();\n          applied++;\n        } else {\n          skipped++;\n        }\n        break;\n        \n      case \"deprecate\":\n        const toDeprecate = findBullet(playbook, delta.bulletId);\n        if (toDeprecate) {\n          toDeprecate.deprecated = true;\n          toDeprecate.deprecationReason = delta.reason;\n          toDeprecate.replacedBy = delta.replacedBy;\n          toDeprecate.state = \"retired\";\n          toDeprecate.updatedAt = now();\n          applied++;\n        } else {\n          skipped++;\n        }\n        break;\n        \n      case \"merge\":\n        // Merge multiple bullets into one\n        const toMerge = delta.bulletIds.map(id =\u003e findBullet(playbook, id)).filter(Boolean);\n        if (toMerge.length \u003e= 2) {\n          const merged = mergeBullets(toMerge, delta.mergedContent);\n          playbook.bullets.push(merged);\n          toMerge.forEach(b =\u003e {\n            b.deprecated = true;\n            b.deprecationReason = \"Merged into \" + merged.id;\n            b.replacedBy = merged.id;\n          });\n          applied++;\n        } else {\n          skipped++;\n        }\n        break;\n    }\n  }\n  \n  // Update playbook metadata\n  playbook.metadata.lastReflection = now();\n  playbook.metadata.totalReflections++;\n  \n  return { playbook, applied, skipped };\n}\n```\n\n## Auto-Pruning (Decay-Aware)\n```typescript\nfunction autoPrunePlaybook(playbook: Playbook, config: Config): number {\n  const before = playbook.bullets.length;\n  \n  playbook.bullets = playbook.bullets.filter(b =\u003e {\n    // Never prune explicitly deprecated (user decision)\n    if (b.deprecated) return true;\n    \n    // Calculate effective score with decay\n    const score = getEffectiveScore(b, config);\n    \n    // Prune if score is significantly negative\n    return score \u003e -config.pruneHarmfulThreshold;\n  });\n  \n  return before - playbook.bullets.length;\n}\n```","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:22:34.23458-05:00","updated_at":"2025-12-07T16:22:34.23458-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew.5","depends_on_id":"cass_memory_system-0ew","type":"parent-child","created_at":"2025-12-07T16:22:34.235563-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.5","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:23:19.118405-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.5","depends_on_id":"cass_memory_system-5eh.6","type":"blocks","created_at":"2025-12-07T16:23:19.211627-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.5","depends_on_id":"cass_memory_system-5eh.3","type":"blocks","created_at":"2025-12-07T16:23:19.288014-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-0ew.6","title":"Anti-Pattern Inversion (P3)","description":"# Feature: Anti-Pattern Inversion (P3 - 8× Impact)\n\n## Purpose\nWhen a bullet proves consistently harmful, instead of just deleting it,\nINVERT it into an anti-pattern. This preserves the negative learning:\n\"We tried X and it caused problems, so DON'T do X.\"\n\n## The Problem\nWithout inversion:\n- Rule: \"Use singleton pattern for database connections\"\n- Gets marked harmful 5 times (causes connection leaks)\n- System deletes it\n- 3 months later, someone proposes the same rule again\n- The failure is forgotten, cycle repeats\n\nWith inversion:\n- Rule gets inverted to: \"AVOID: Singleton pattern for database connections (causes connection leaks)\"\n- Marked as kind=anti_pattern\n- Future proposals matching this pattern trigger warnings\n\n## Implementation\n```typescript\nfunction shouldInvertToAntiPattern(bullet: PlaybookBullet, config: Config): boolean {\n  const { decayedHelpful, decayedHarmful } = getDecayedCounts(bullet, config);\n  \n  // Inversion threshold: harmful significantly outweighs helpful\n  // AND we have enough data points to be confident\n  return (\n    decayedHarmful \u003e= 3 \u0026\u0026                    // Minimum harmful events\n    decayedHarmful \u003e decayedHelpful * 2 \u0026\u0026    // 2:1 harmful:helpful ratio\n    !bullet.deprecated                         // Not already handled\n  );\n}\n\nfunction invertToAntiPattern(\n  bullet: PlaybookBullet,\n  reason: string\n): PlaybookBullet {\n  // Create inverted content\n  const invertedContent = generateAntiPatternContent(bullet.content, reason);\n  \n  return {\n    ...bullet,\n    id: generateBulletId(), // New ID for the anti-pattern\n    kind: \"anti_pattern\",\n    content: invertedContent,\n    \n    // Reset feedback (this is a new bullet)\n    feedbackEvents: [],\n    helpfulCount: 0,\n    harmfulCount: 0,\n    state: \"draft\",\n    \n    // Track provenance\n    sourceSessions: bullet.sourceSessions,\n    sourceAgents: bullet.sourceAgents,\n    tags: [...bullet.tags, \"inverted\", \"anti-pattern\"],\n    \n    createdAt: now(),\n    updatedAt: now()\n  };\n}\n\nfunction generateAntiPatternContent(\n  originalContent: string,\n  reason: string\n): string {\n  // Transform positive advice into negative warning\n  // \"Use X for Y\" → \"AVOID: X for Y (causes Z)\"\n  \n  // Simple heuristic transformation\n  const cleaned = originalContent\n    .replace(/^(always |prefer |use |try |consider )/i, \"\")\n    .trim();\n  \n  return `AVOID: ${cleaned}. ${reason}`;\n}\n```\n\n## Integration with Curator\n```typescript\nfunction curatePlaybook(playbook: Playbook, deltas: Delta[], config: Config) {\n  // ... apply deltas ...\n  \n  // Check for bullets that should be inverted\n  for (const bullet of playbook.bullets) {\n    if (shouldInvertToAntiPattern(bullet, config)) {\n      const antiPattern = invertToAntiPattern(\n        bullet,\n        `Marked harmful ${bullet.harmfulCount} times`\n      );\n      \n      // Add anti-pattern\n      playbook.bullets.push(antiPattern);\n      \n      // Deprecate original\n      bullet.deprecated = true;\n      bullet.deprecationReason = `Inverted to anti-pattern: ${antiPattern.id}`;\n      bullet.replacedBy = antiPattern.id;\n      bullet.state = \"retired\";\n    }\n  }\n}\n```\n\n## Example Inversion\n**Before** (harmful rule):\n```yaml\n- id: \"b-abc123\"\n  kind: \"stack_pattern\"\n  content: \"Use global mutable state for sharing data between components\"\n  harmfulCount: 5\n  helpfulCount: 1\n```\n\n**After** (anti-pattern):\n```yaml\n- id: \"b-def456\"\n  kind: \"anti_pattern\"\n  content: \"AVOID: Global mutable state for sharing data between components. Marked harmful 5 times - causes race conditions and debugging nightmares.\"\n  tags: [\"inverted\", \"anti-pattern\", \"state-management\"]\n  \n- id: \"b-abc123\"\n  deprecated: true\n  deprecationReason: \"Inverted to anti-pattern: b-def456\"\n  replacedBy: \"b-def456\"\n  state: \"retired\"\n```","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:22:34.432332-05:00","updated_at":"2025-12-07T16:22:34.432332-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew.6","depends_on_id":"cass_memory_system-0ew","type":"parent-child","created_at":"2025-12-07T16:22:34.438818-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.6","depends_on_id":"cass_memory_system-0ew.5","type":"blocks","created_at":"2025-12-07T16:23:19.358742-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.6","depends_on_id":"cass_memory_system-5eh.6","type":"blocks","created_at":"2025-12-07T16:23:19.429251-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-0ew.7","title":"Forget Command + Toxic Bullet Log (P8)","description":"# Feature: Forget Command + Toxic Bullet Log (P8)\n\n## Purpose\nPermanently block a pattern that should NEVER be suggested again.\nMore severe than deprecation - this is for truly harmful patterns\nthat caused production issues, security problems, etc.\n\n## Usage\n```bash\ncass-memory forget b-abc123 --reason \"Caused production outage\"\ncass-memory forget --list  # Show toxic bullet log\n```\n\n## Difference from Deprecation\n| Aspect | Deprecate | Forget |\n|--------|-----------|--------|\n| Reversible | Yes | No (requires manual edit) |\n| Stays in playbook | Yes (marked deprecated) | Removed entirely |\n| Future proposals | Allowed | Blocked via semantic matching |\n| Audit trail | In playbook | In toxic_bullets.log |\n\n## Implementation\n```typescript\nasync function forgetCommand(\n  bulletId: string,\n  flags: { reason: string; list?: boolean }\n): Promise\u003cvoid\u003e {\n  if (flags.list) {\n    return listToxicBullets();\n  }\n  \n  const config = await loadConfig();\n  const playbook = await loadMergedPlaybook(config);\n  \n  // Find bullet\n  const bullet = findBullet(playbook, bulletId);\n  if (!bullet) {\n    error(`Bullet not found: ${bulletId}`);\n    process.exit(1);\n  }\n  \n  // Log to toxic bullets file BEFORE removing\n  await appendToxicLog({\n    id: bullet.id,\n    content: bullet.content,\n    reason: flags.reason,\n    forgottenAt: now(),\n    originalBullet: bullet\n  });\n  \n  // Remove from playbook\n  playbook.bullets = playbook.bullets.filter(b =\u003e b.id !== bulletId);\n  \n  await savePlaybook(playbook, config.playbookPath);\n  \n  output({\n    success: true,\n    bulletId,\n    action: \"forgotten\",\n    reason: flags.reason\n  }, formatForgetResult, flags);\n}\n```\n\n## Toxic Bullet Log Format\n```\n~/.cass-memory/toxic_bullets.log\n# One JSON object per line\n{\"id\":\"b-abc123\",\"content\":\"Use eval() for dynamic code execution\",\"reason\":\"Security vulnerability - allows code injection\",\"forgottenAt\":\"2025-12-07T10:30:00Z\"}\n```\n\n## Blocking Future Proposals\nWhen the curator processes new \"add\" deltas, check against toxic log:\n```typescript\nasync function isSemanticallyToxic(\n  content: string,\n  toxicPatterns: ToxicEntry[]\n): Promise\u003cboolean\u003e {\n  for (const toxic of toxicPatterns) {\n    const similarity = jaccardSimilarity(content, toxic.content);\n    if (similarity \u003e 0.7) {\n      log(`Blocked: \"${content}\" matches toxic pattern \"${toxic.content}\"`);\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n## Cascading Toxic Logs\nBoth global and repo-level toxic logs are checked:\n```typescript\nconst globalToxic = await loadToxicLog(\"~/.cass-memory/toxic_bullets.log\");\nconst repoToxic = await loadToxicLog(\"./.cass/toxic.log\");\nconst allToxic = [...globalToxic, ...repoToxic];\n```\n\n## List Output\n```bash\n$ cass-memory forget --list\n\nTOXIC BULLETS (permanently blocked):\n\n[b-abc123] 2025-12-07\n  \"Use eval() for dynamic code execution\"\n  Reason: Security vulnerability - allows code injection\n\n[b-def456] 2025-11-15  \n  \"Store passwords in localStorage\"\n  Reason: Security violation - passwords must never be in client storage\n```","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:22:34.672378-05:00","updated_at":"2025-12-07T16:22:34.672378-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew.7","depends_on_id":"cass_memory_system-0ew","type":"parent-child","created_at":"2025-12-07T16:22:34.674322-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.7","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:23:19.508632-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-0ew.8","title":"Doctor Command: System Health Check (P13)","description":"# Feature: Doctor Command (P13 - 5× DX Impact)\n\n## Purpose\nComprehensive system health check. Catches configuration issues, missing\ndependencies, stale data, and other problems BEFORE they cause failures.\n\n## Usage\n```bash\ncass-memory doctor\ncass-memory doctor --fix  # Auto-fix simple issues\ncass-memory doctor --json\n```\n\n## Checks Performed\n\n### 1. Configuration Checks\n- Config file exists and is valid JSON\n- Required fields present\n- API key environment variables set\n- Paths are writable\n\n### 2. Dependency Checks  \n- cass is available and healthy\n- cass index is up to date\n- LLM API is reachable (optional ping)\n\n### 3. Data Integrity Checks\n- Playbook YAML is valid\n- No orphaned bullet references\n- No circular deprecation chains\n- feedbackEvents timestamps are valid ISO 8601\n\n### 4. Health Metrics\n- Bullets with negative effective scores\n- Stale bullets (no feedback in 90+ days)\n- High harmful ratio bullets\n- Duplicate content detection\n\n## Implementation\n```typescript\ninterface DoctorCheck {\n  name: string;\n  status: \"pass\" | \"warn\" | \"fail\";\n  message: string;\n  fixable?: boolean;\n  fix?: () =\u003e Promise\u003cvoid\u003e;\n}\n\nasync function doctorCommand(flags: { fix?: boolean; json?: boolean }): Promise\u003cvoid\u003e {\n  const checks: DoctorCheck[] = [];\n  \n  // Configuration checks\n  checks.push(await checkConfigExists());\n  checks.push(await checkConfigValid());\n  checks.push(await checkApiKeys());\n  \n  // Dependency checks\n  checks.push(await checkCassAvailable());\n  checks.push(await checkCassIndex());\n  \n  // Data integrity checks\n  checks.push(await checkPlaybookValid());\n  checks.push(await checkNoOrphanedRefs());\n  checks.push(await checkNoCircularDeprecations());\n  checks.push(await checkTimestampsValid());\n  \n  // Health metrics\n  checks.push(await checkNegativeScoreBullets());\n  checks.push(await checkStaleBullets());\n  checks.push(await checkHighHarmfulRatio());\n  checks.push(await checkDuplicateContent());\n  \n  // Auto-fix if requested\n  if (flags.fix) {\n    for (const check of checks.filter(c =\u003e c.status !== \"pass\" \u0026\u0026 c.fixable)) {\n      await check.fix?.();\n      check.status = \"pass\";\n      check.message += \" (auto-fixed)\";\n    }\n  }\n  \n  // Output\n  output({ checks, summary: summarizeChecks(checks) }, formatDoctorResult, flags);\n  \n  // Exit code based on results\n  const hasFailures = checks.some(c =\u003e c.status === \"fail\");\n  if (hasFailures) process.exit(1);\n}\n```\n\n## Example Output\n```\n╭─────────────────────────────────────────────────────────────╮\n│                   CASS-MEMORY DOCTOR                        │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│ CONFIGURATION                                               │\n│   ✓ Config file exists                                      │\n│   ✓ Config is valid JSON                                    │\n│   ✓ ANTHROPIC_API_KEY is set                                │\n│                                                             │\n│ DEPENDENCIES                                                │\n│   ✓ cass is available (v0.5.2)                              │\n│   ⚠ cass index is 3 days old (run: cass index --incremental)│\n│                                                             │\n│ DATA INTEGRITY                                              │\n│   ✓ Playbook YAML is valid                                  │\n│   ✓ No orphaned references                                  │\n│   ✓ No circular deprecations                                │\n│                                                             │\n│ PLAYBOOK HEALTH                                             │\n│   ⚠ 3 bullets have negative effective scores                │\n│   ⚠ 12 bullets are stale (no feedback in 90+ days)          │\n│   ✓ No high harmful ratio bullets                           │\n│   ⚠ 2 potential duplicate pairs detected                    │\n│                                                             │\n├─────────────────────────────────────────────────────────────┤\n│ Summary: 8 passed, 4 warnings, 0 failures                   │\n│                                                             │\n│ Recommendations:                                            │\n│   • Run `cass index --incremental` to update search index   │\n│   • Review bullets with negative scores:                    │\n│     cass-memory playbook list --at-risk                     │\n│   • Consider merging duplicate bullets:                     │\n│     cass-memory similar b-abc123                            │\n╰─────────────────────────────────────────────────────────────╯\n```","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:22:34.902332-05:00","updated_at":"2025-12-07T16:22:34.902332-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew.8","depends_on_id":"cass_memory_system-0ew","type":"parent-child","created_at":"2025-12-07T16:22:34.903228-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.8","depends_on_id":"cass_memory_system-5eh.7","type":"blocks","created_at":"2025-12-07T16:23:19.581038-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.8","depends_on_id":"cass_memory_system-5eh.4","type":"blocks","created_at":"2025-12-07T16:23:19.664395-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.8","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:23:19.735154-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-0ew.9","title":"Reflect Command: cass-memory reflect (Full Pipeline)","description":"# Feature: Reflect Command (Full Pipeline Orchestration)\n\n## Purpose\nOrchestrate the full diary → reflect → validate → curate pipeline.\nThis is the command that makes the playbook learn from recent sessions.\n\n## Usage\n```bash\ncass-memory reflect --days 7 --max-sessions 10\ncass-memory reflect --dry-run --json  # See what would happen\ncass-memory reflect --session ~/.claude/sessions/abc.jsonl  # Single session\n```\n\n## Process Flow\n```\n1. Find unprocessed sessions (not in processed.log)\n2. For each session:\n   a. Generate diary (if not exists)\n   b. Run reflector (extract deltas)\n   c. Run validator on \"add\" deltas (evidence gate + LLM)\n   d. Apply deltas via curator\n   e. Mark session as processed\n3. Save updated playbook\n4. Run auto-prune\n5. Check for anti-pattern inversions\n```\n\n## Implementation\n```typescript\nasync function reflectCommand(flags: ReflectFlags): Promise\u003cvoid\u003e {\n  const config = await loadConfig();\n  const playbook = await loadMergedPlaybook(config);\n  \n  // 1. Find sessions to process\n  const sessions = flags.session\n    ? [{ path: flags.session, agent: detectAgent(flags.session) }]\n    : await findUnprocessedSessions(config);\n  \n  if (sessions.length === 0) {\n    output({ message: \"No new sessions to process\" }, null, flags);\n    return;\n  }\n  \n  const results: ReflectionResult[] = [];\n  \n  // 2. Process each session\n  for (const session of sessions.slice(0, flags.maxSessions || 10)) {\n    // 2a. Generate diary\n    let diary = await loadDiary(session.path);\n    if (!diary) {\n      diary = await generateDiary(session.path, session.agent, config);\n      await saveDiary(diary);\n    }\n    \n    // 2b. Run reflector\n    const deltas = await reflectOnSession(diary, playbook, config);\n    \n    // 2c. Validate \"add\" deltas\n    const validatedDeltas: Delta[] = [];\n    for (const delta of deltas) {\n      if (delta.type === \"add\" \u0026\u0026 config.validationEnabled) {\n        const validation = await validateRule(delta.bullet.content, config);\n        if (validation.valid) {\n          // Optionally use refined content\n          if (validation.refinedContent) {\n            delta.bullet.content = validation.refinedContent;\n          }\n          validatedDeltas.push(delta);\n        }\n      } else {\n        validatedDeltas.push(delta);\n      }\n    }\n    \n    // 2d. Dry run check\n    if (flags.dryRun) {\n      results.push({\n        session: session.path,\n        diary,\n        proposedDeltas: validatedDeltas,\n        applied: false\n      });\n      continue;\n    }\n    \n    // 2e. Apply deltas\n    const { applied, skipped } = curatePlaybook(playbook, validatedDeltas, config);\n    \n    // 2f. Mark processed\n    await markSessionProcessed(session.path);\n    \n    results.push({\n      session: session.path,\n      diary,\n      proposedDeltas: validatedDeltas,\n      applied: true,\n      deltasApplied: applied,\n      deltasSkipped: skipped\n    });\n  }\n  \n  // 3. Save playbook (if not dry run)\n  if (!flags.dryRun) {\n    // Run anti-pattern inversion check\n    checkAndInvertAntiPatterns(playbook, config);\n    \n    // Auto-prune\n    const pruned = autoPrunePlaybook(playbook, config);\n    \n    await savePlaybook(playbook, config.playbookPath);\n    \n    output({\n      sessionsProcessed: results.length,\n      results,\n      pruned\n    }, formatReflectResult, flags);\n  } else {\n    output({\n      dryRun: true,\n      sessionsAnalyzed: results.length,\n      results\n    }, formatReflectDryRun, flags);\n  }\n}\n```\n\n## Processed Log\n```\n~/.cass-memory/reflections/global.processed.log\n# Format: {diaryId}\\t{timestamp}\\t{sessionPath}\ndiary-abc123\t2025-12-07T10:30:00Z\t~/.claude/sessions/session-001.jsonl\ndiary-def456\t2025-12-07T11:00:00Z\t~/.cursor/state.vscdb:session-xyz\n```\n\n## Output (--json)\n```json\n{\n  \"sessionsProcessed\": 3,\n  \"results\": [\n    {\n      \"session\": \"~/.claude/sessions/abc.jsonl\",\n      \"deltasApplied\": 5,\n      \"deltasSkipped\": 2,\n      \"newBullets\": [\"b-abc123\", \"b-def456\"],\n      \"helpfulMarks\": 2,\n      \"harmfulMarks\": 1\n    }\n  ],\n  \"pruned\": 0,\n  \"antiPatternsInverted\": 0\n}\n```","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:23:02.233237-05:00","updated_at":"2025-12-07T16:23:02.233237-05:00","dependencies":[{"issue_id":"cass_memory_system-0ew.9","depends_on_id":"cass_memory_system-0ew","type":"parent-child","created_at":"2025-12-07T16:23:02.234721-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.9","depends_on_id":"cass_memory_system-0ew.1","type":"blocks","created_at":"2025-12-07T16:23:19.815499-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.9","depends_on_id":"cass_memory_system-0ew.3","type":"blocks","created_at":"2025-12-07T16:23:19.887792-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.9","depends_on_id":"cass_memory_system-0ew.4","type":"blocks","created_at":"2025-12-07T16:23:19.959156-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.9","depends_on_id":"cass_memory_system-0ew.5","type":"blocks","created_at":"2025-12-07T16:23:20.025207-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-0ew.9","depends_on_id":"cass_memory_system-0ew.6","type":"blocks","created_at":"2025-12-07T16:23:20.1012-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-3l7","title":"Phase 4: Polish \u0026 Integration","description":"# EPIC: Polish \u0026 Integration\n\n## Purpose\nProduction-ready release: audit capabilities, AGENTS.md export, comprehensive\nerror handling, binary compilation, and documentation.\n\n## Background \u0026 Reasoning\nFor cass-memory to be adopted by teams, it needs:\n1. Audit capabilities to verify agents follow playbook rules\n2. Easy export to AGENTS.md/CLAUDE.md formats agents already read\n3. Tombstone/deprecated pattern support for gradual deprecation\n4. Cross-platform binaries for easy distribution\n5. Comprehensive documentation and examples\n\n## Key Deliverables\n1. `cass-memory audit --days N` - Check sessions for rule violations\n2. `cass-memory project --format agents.md` - Export to agent config\n3. Deprecated patterns/tombstone mechanism\n4. Binary compilation for Linux/macOS/Windows\n5. README.md with usage examples\n6. AGENTS.md template for memory protocol\n\n## Additional Commands from Plan\n- `cass-memory top` - Show top-performing bullets\n- `cass-memory stale` - List bullets needing refresh\n- `cass-memory why \u003cid\u003e` - Explain bullet provenance\n- `cass-memory similar \u003cid\u003e` - Find related bullets\n\n## Future Enhancements (Post-MVP)\n- MCP server mode for direct agent integration\n- Team playbooks with merge/conflict resolution\n- Visualization of playbook evolution\n- Pattern detection across sessions\n- Auto-reflection hooks (post-session triggers)\n- Conflict detection between bullets\n\n## Dependencies\n- Requires Phase 3 completion (semantic search, stats)","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-07T16:16:42.78245-05:00","updated_at":"2025-12-07T16:16:42.78245-05:00","dependencies":[{"issue_id":"cass_memory_system-3l7","depends_on_id":"cass_memory_system-y8o","type":"blocks","created_at":"2025-12-07T16:25:25.759026-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-3l7.1","title":"Audit Command: cass-memory audit","description":"# Feature: Audit Command\n\n## Purpose\nCheck recent sessions for playbook rule violations. Helps identify:\n- Rules that agents are ignoring\n- Rules that may be unclear or hard to follow\n- Opportunities for training/documentation\n\n## Usage\n```bash\ncass-memory audit --days 7 --json\ncass-memory audit --session ~/.claude/sessions/abc.jsonl\ncass-memory audit --severity high\n```\n\n## Process Flow\n```\n1. Load recent sessions from cass\n2. For each session, check against playbook rules\n3. LLM identifies potential violations\n4. Classify severity and suggest improvements\n```\n\n## Implementation\n```typescript\nasync function auditCommand(flags: AuditFlags): Promise\u003cvoid\u003e {\n  const config = await loadConfig();\n  const playbook = await loadMergedPlaybook(config);\n  \n  // Get sessions to audit\n  const sessions = flags.session\n    ? [flags.session]\n    : await getRecentSessions(config.cassPath, flags.days || 7);\n  \n  const violations: AuditViolation[] = [];\n  \n  for (const sessionPath of sessions) {\n    const content = await cassExport(sessionPath, \"markdown\", config.cassPath);\n    if (!content) continue;\n    \n    // LLM audit\n    const result = await runAudit(\n      AuditOutputSchema,\n      content,\n      formatRulesForAudit(playbook.bullets.filter(b =\u003e !b.deprecated)),\n      config\n    );\n    \n    violations.push(...result.violations.map(v =\u003e ({\n      ...v,\n      sessionPath\n    })));\n  }\n  \n  // Filter by severity if requested\n  const filtered = flags.severity\n    ? violations.filter(v =\u003e v.severity === flags.severity)\n    : violations;\n  \n  output({\n    sessionsAudited: sessions.length,\n    totalViolations: filtered.length,\n    violations: filtered,\n    summary: summarizeViolations(filtered)\n  }, formatAuditResult, flags);\n}\n```\n\n## Violation Schema\n```typescript\ninterface AuditViolation {\n  bulletId: string;\n  bulletContent: string;\n  sessionPath: string;\n  evidence: string;        // Quote from session\n  severity: \"low\" | \"medium\" | \"high\";\n  suggestion?: string;     // How to improve\n}\n```\n\n## Output Example\n```\n╭─────────────────────────────────────────────────────────────╮\n│                    AUDIT RESULTS                            │\n├─────────────────────────────────────────────────────────────┤\n│ Sessions audited: 5                                         │\n│ Violations found: 3                                         │\n│                                                             │\n│ HIGH SEVERITY (1):                                          │\n│   [b-abc123] \"Always run tests before committing\"           │\n│   Session: ~/.claude/sessions/xyz.jsonl                     │\n│   Evidence: \"Committed changes without running test suite\"  │\n│                                                             │\n│ MEDIUM SEVERITY (2):                                        │\n│   [b-def456] \"Use TypeScript strict mode\"                   │\n│   Session: ~/.cursor/sessions/abc.jsonl                     │\n│   Evidence: \"Added // @ts-ignore to bypass type error\"      │\n╰─────────────────────────────────────────────────────────────╯\n```","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-07T16:25:08.126872-05:00","updated_at":"2025-12-07T16:25:08.126872-05:00","dependencies":[{"issue_id":"cass_memory_system-3l7.1","depends_on_id":"cass_memory_system-3l7","type":"parent-child","created_at":"2025-12-07T16:25:08.128675-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-3l7.1","depends_on_id":"cass_memory_system-5eh.9","type":"blocks","created_at":"2025-12-07T16:25:25.844795-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-3l7.1","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:25:25.932005-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-3l7.1","depends_on_id":"cass_memory_system-5eh.4","type":"blocks","created_at":"2025-12-07T16:25:26.02106-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-3l7.2","title":"Project Command: Export to AGENTS.md","description":"# Feature: Project Command (Export to AGENTS.md)\n\n## Purpose\nExport playbook to agent-readable formats (AGENTS.md, CLAUDE.md).\nThis is how accumulated knowledge gets into the agent's context.\n\n## Usage\n```bash\ncass-memory project --format agents.md --output ./AGENTS.md\ncass-memory project --format claude.md --top 30\ncass-memory project --category testing,debugging\n```\n\n## Output Formats\n\n### AGENTS.md Format\n```markdown\n## Memory System: cass-memory\n\nBefore starting complex tasks, retrieve context:\n\\`\\`\\`bash\ncass-memory context \"\u003ctask\u003e\" --json\n\\`\\`\\`\n\n### Top Rules by Category\n\n#### Testing (8 rules)\n- [b-abc123] For React hooks, test effects separately with renderHook\n- [b-def456] Mock external APIs at the service layer, not in tests\n- ...\n\n#### Debugging (5 rules)\n- [b-ghi789] Enable DEBUG=auth:* for authentication issues\n- ...\n\n### Memory Protocol\n1. PRE-FLIGHT: Run `cass-memory context` before non-trivial tasks\n2. REFERENCE: Cite bullet IDs when following rules\n3. FEEDBACK: Mark bullets helpful/harmful as you work\n```\n\n### CLAUDE.md Format (Condensed)\n```markdown\n# Project Rules (via cass-memory)\n\nTesting:\n• Test React hooks with renderHook, effects separately [b-abc123]\n• Mock APIs at service layer [b-def456]\n\nDebugging:\n• Use DEBUG=auth:* for auth issues [b-ghi789]\n```\n\n## Implementation\n```typescript\nasync function projectCommand(flags: ProjectFlags): Promise\u003cvoid\u003e {\n  const config = await loadConfig();\n  const playbook = await loadMergedPlaybook(config);\n  \n  // Filter and sort bullets\n  const bullets = playbook.bullets\n    .filter(b =\u003e !b.deprecated \u0026\u0026 b.state !== \"retired\")\n    .filter(b =\u003e !flags.category || flags.category.includes(b.category))\n    .sort((a, b) =\u003e getEffectiveScore(b, config) - getEffectiveScore(a, config))\n    .slice(0, flags.top || 50);\n  \n  // Group by category\n  const byCategory = groupBy(bullets, b =\u003e b.category);\n  \n  // Generate output\n  const content = flags.format === \"agents.md\"\n    ? generateAgentsMd(byCategory, playbook.deprecatedPatterns)\n    : generateClaudeMd(byCategory);\n  \n  if (flags.output) {\n    await writeFile(flags.output, content);\n    console.log(`Exported to ${flags.output}`);\n  } else {\n    console.log(content);\n  }\n}\n```\n\n## Category Sorting\nCategories are sorted by total effective score of their bullets,\nso the most impactful categories appear first.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-07T16:25:08.353916-05:00","updated_at":"2025-12-07T16:25:08.353916-05:00","dependencies":[{"issue_id":"cass_memory_system-3l7.2","depends_on_id":"cass_memory_system-3l7","type":"parent-child","created_at":"2025-12-07T16:25:08.354826-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-3l7.2","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:25:26.102059-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-3l7.2","depends_on_id":"cass_memory_system-5eh.6","type":"blocks","created_at":"2025-12-07T16:25:26.171665-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-3l7.3","title":"Binary Compilation + Distribution","description":"# Feature: Binary Compilation + Distribution\n\n## Purpose\nCompile cass-memory to standalone binaries for easy distribution.\nUsers shouldn't need Bun installed to use the tool.\n\n## Build Targets\n- Linux x64: dist/cass-memory-linux-x64\n- macOS ARM64: dist/cass-memory-darwin-arm64\n- macOS x64: dist/cass-memory-darwin-x64\n- Windows x64: dist/cass-memory-windows-x64.exe\n\n## Build Commands\n```json\n{\n  \"scripts\": {\n    \"build\": \"bun build src/cass-memory.ts --compile --outfile dist/cass-memory\",\n    \"build:all\": \"npm run build:linux \u0026\u0026 npm run build:macos-arm \u0026\u0026 npm run build:macos-x64 \u0026\u0026 npm run build:windows\",\n    \"build:linux\": \"bun build src/cass-memory.ts --compile --target=bun-linux-x64 --outfile dist/cass-memory-linux-x64\",\n    \"build:macos-arm\": \"bun build src/cass-memory.ts --compile --target=bun-darwin-arm64 --outfile dist/cass-memory-darwin-arm64\",\n    \"build:macos-x64\": \"bun build src/cass-memory.ts --compile --target=bun-darwin-x64 --outfile dist/cass-memory-darwin-x64\",\n    \"build:windows\": \"bun build src/cass-memory.ts --compile --target=bun-windows-x64 --outfile dist/cass-memory-windows-x64.exe\"\n  }\n}\n```\n\n## Binary Size Considerations\n- Base Bun runtime: ~50MB\n- Application code: ~200KB\n- Dependencies: ~5MB (mostly AI SDK)\n- Total: ~55MB per binary\n\n## Distribution Options\n1. GitHub Releases (primary)\n2. Homebrew formula (macOS)\n3. npm/bun global install (for developers)\n\n## Installation Instructions\n```bash\n# macOS (Homebrew)\nbrew install cass-memory\n\n# Direct download\ncurl -L https://github.com/org/cass-memory/releases/latest/download/cass-memory-darwin-arm64 -o cass-memory\nchmod +x cass-memory\nsudo mv cass-memory /usr/local/bin/\n\n# npm/bun\nbun install -g cass-memory\n```","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-07T16:25:09.629265-05:00","updated_at":"2025-12-07T16:25:09.629265-05:00","dependencies":[{"issue_id":"cass_memory_system-3l7.3","depends_on_id":"cass_memory_system-3l7","type":"parent-child","created_at":"2025-12-07T16:25:09.630419-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-3l7.3","depends_on_id":"cass_memory_system-5eh.10","type":"blocks","created_at":"2025-12-07T16:25:26.253012-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-3l7.4","title":"Documentation: README.md + Examples","description":"# Feature: Documentation\n\n## Purpose\nComprehensive documentation for users and contributors.\n\n## Files to Create\n\n### README.md\n```markdown\n# cass-memory\n\nAgent-agnostic reflection and memory system for coding agents.\nImplements the ACE (Agentic Context Engineering) framework.\n\n## Quick Start\n\n\\`\\`\\`bash\n# Install\nbrew install cass-memory  # or download binary\n\n# Initialize\ncass-memory init\n\n# Get context before a task\ncass-memory context \"Fix authentication timeout\" --json\n\n# Mark rules as helpful/harmful\ncass-memory mark b-abc123 --helpful\ncass-memory mark b-def456 --harmful --reason \"Caused test failures\"\n\n# Run reflection on recent sessions\ncass-memory reflect --days 7\n\n# Check playbook health\ncass-memory stats\ncass-memory doctor\n\\`\\`\\`\n\n## How It Works\n\ncass-memory implements three memory layers:\n\n1. **Episodic Memory** (cass): Raw session logs from all agents\n2. **Working Memory** (Diary): Structured session summaries\n3. **Procedural Memory** (Playbook): Distilled rules with feedback tracking\n\n## Configuration\n\n\\`\\`\\`bash\n# Set your LLM provider\nexport ANTHROPIC_API_KEY=sk-ant-...\n# or\nexport OPENAI_API_KEY=sk-...\n\n# Configure\ncass-memory config --provider anthropic --model claude-sonnet-4-20250514\n\\`\\`\\`\n\n## Integration\n\nAdd to your AGENTS.md or CLAUDE.md:\n\\`\\`\\`\ncass-memory project --format agents.md \u003e\u003e AGENTS.md\n\\`\\`\\`\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| init | Initialize configuration |\n| context | Get pre-task context |\n| diary | Generate diary from session |\n| reflect | Run reflection pipeline |\n| mark | Record feedback |\n| forget | Permanently block pattern |\n| stats | Show playbook health |\n| doctor | System health check |\n| audit | Check for violations |\n| project | Export to AGENTS.md |\n\\`\\`\\`\n\n### Examples Directory\n- examples/basic-workflow.md\n- examples/team-setup.md\n- examples/ci-integration.md\n```","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-07T16:25:10.905798-05:00","updated_at":"2025-12-07T16:25:10.905798-05:00","dependencies":[{"issue_id":"cass_memory_system-3l7.4","depends_on_id":"cass_memory_system-3l7","type":"parent-child","created_at":"2025-12-07T16:25:10.906922-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-3l7.4","depends_on_id":"cass_memory_system-3l7.1","type":"blocks","created_at":"2025-12-07T16:25:26.323742-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-3l7.4","depends_on_id":"cass_memory_system-3l7.2","type":"blocks","created_at":"2025-12-07T16:25:26.39861-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh","title":"Phase 1: Foundation + High-ROI Core","description":"# EPIC: Foundation + High-ROI Core\n\n## Purpose\nEstablish the core infrastructure and implement the highest-ROI features that provide immediate value. This phase creates the skeleton upon which all other features build.\n\n## Background \u0026 Reasoning\nThe ACE (Agentic Context Engineering) framework emphasizes three key innovations:\n1. **Generator** - Pre-task context hydration\n2. **Reflector** - LLM-powered insight extraction  \n3. **Curator** - Deterministic delta merging (NO LLM rewriting)\n\nThis phase implements the Generator (context command) and foundational types needed for all subsequent phases.\n\n## Priority Features (from ROI analysis)\n- P1: Confidence decay + event timestamps (20× impact)\n- P2: Structured JSON context output (10× impact)\n- P4: Effective score (4× harmful multiplier) (5× impact)\n- P10: State lifecycle draft/active/retired (10× impact)\n- P12: Secret sanitization (∞ security-critical)\n- P14: Kind enum categorization (3× impact)\n\n## Key Deliverables\n1. `cass-memory init` - Initialize configuration and playbook\n2. `cass-memory context --json` - Pre-flight task hydration\n3. Complete type system with all enhancements\n4. cass integration wrapper with error handling\n5. Secret sanitization pipeline\n\n## Architecture Decisions\n- Use Bun for all JS/TS operations (per AGENTS.md rules)\n- Vercel AI SDK for LLM provider abstraction\n- Zod for runtime type validation and LLM structured output\n- YAML for playbook storage (human-readable, git-friendly)\n\n## Success Criteria\n- An agent can run `cass-memory context \"task\"` and receive relevant bullets\n- Bullets have proper decay-adjusted scores\n- No secrets leak into stored diary entries or playbook\n- Configuration cascades from global to repo-level\n\n## Dependencies\nNone - this is the foundation phase","status":"open","priority":0,"issue_type":"epic","created_at":"2025-12-07T16:16:01.370891-05:00","updated_at":"2025-12-07T16:16:01.370891-05:00"}
{"id":"cass_memory_system-5eh.1","title":"Project Setup: Bun + TypeScript + Dependencies","description":"# Feature: Project Setup\n\n## Purpose\nInitialize the project with Bun, TypeScript, and all required dependencies.\n\n## Technical Decisions\n- **Runtime**: Bun (per AGENTS.md: \"Use bun for everything JS/TS\")\n- **LLM SDK**: Vercel AI SDK (supports OpenAI, Anthropic, Google)\n- **Validation**: Zod (structured LLM output, runtime type safety)\n- **YAML**: yaml package (for playbook read/write)\n- **Output**: chalk (terminal colors for human-readable output)\n\n## Files to Create\n1. `package.json` - Dependencies, scripts, bin entry\n2. `tsconfig.json` - TypeScript configuration\n3. `src/` directory structure\n\n## Package.json Specifics\n```json\n{\n  \"name\": \"cass-memory\",\n  \"version\": \"0.1.0\",\n  \"type\": \"module\",\n  \"bin\": { \"cass-memory\": \"./dist/cass-memory.js\" },\n  \"scripts\": {\n    \"dev\": \"bun run src/cass-memory.ts\",\n    \"build\": \"bun build src/cass-memory.ts --compile --outfile dist/cass-memory\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"bun test\"\n  },\n  \"dependencies\": {\n    \"ai\": \"^4.0.0\",\n    \"@ai-sdk/openai\": \"^1.0.0\",\n    \"@ai-sdk/anthropic\": \"^1.0.0\", \n    \"@ai-sdk/google\": \"^1.0.0\",\n    \"zod\": \"^3.23.0\",\n    \"yaml\": \"^2.3.0\",\n    \"chalk\": \"^5.3.0\"\n  },\n  \"devDependencies\": {\n    \"@types/bun\": \"latest\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n```\n\n## Acceptance Criteria\n- `bun install` succeeds\n- `bun run dev --help` shows CLI help\n- `bun run typecheck` passes\n- Directory structure matches plan\n\n## No Dependencies\nThis is the first task.","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:17:15.519346-05:00","updated_at":"2025-12-07T16:17:15.519346-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.1","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:17:15.521212-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.10","title":"CLI Scaffolding: src/cass-memory.ts","description":"# Feature: CLI Scaffolding (src/cass-memory.ts)\n\n## Purpose\nMain CLI entry point with command parsing, help text, and routing to\ncommand handlers.\n\n## CLI Structure\n```\ncass-memory \u003ccommand\u003e [options]\n\nCommands:\n  init              Initialize configuration and playbook\n  context \u003ctask\u003e    Get relevant context for a task (Phase 1)\n  diary \u003cpath\u003e      Generate structured diary from a session (Phase 2)\n  reflect           Run reflection cycle on recent sessions (Phase 2)\n  validate \u003crule\u003e   Validate proposed rule against history (Phase 3)\n  curate            Apply deltas to playbook (Phase 2)\n  mark \u003cid\u003e         Record bullet usage (helpful/harmful) (Phase 2)\n  forget \u003cid\u003e       Permanently block a pattern (Phase 2)\n  audit             Check sessions for rule violations (Phase 4)\n  playbook          Manage playbook entries (Phase 2)\n  project           Export playbook to AGENTS.md (Phase 4)\n  stats             Show playbook health metrics (Phase 3)\n  doctor            Check system health (Phase 2)\n\nGlobal Options:\n  --json            Output in JSON format\n  --verbose         Enable verbose logging\n  --config \u003cpath\u003e   Use custom config file\n  --help            Show help\n  --version         Show version\n```\n\n## Implementation Approach\nUse simple argument parsing (no heavy dependencies):\n```typescript\nconst args = process.argv.slice(2);\nconst command = args[0];\nconst flags = parseFlags(args.slice(1));\n\nswitch (command) {\n  case \"init\": return initCommand(flags);\n  case \"context\": return contextCommand(args[1], flags);\n  // ...\n  default: showHelp();\n}\n```\n\n## Global Flag Handling\n```typescript\ninterface GlobalFlags {\n  json: boolean;\n  verbose: boolean;\n  config?: string;\n  help: boolean;\n  version: boolean;\n}\n\nfunction parseFlags(args: string[]): GlobalFlags \u0026 Record\u003cstring, any\u003e;\n```\n\n## Output Formatting\n```typescript\n// JSON output (for agents)\nfunction outputJson(data: any): void {\n  console.log(JSON.stringify(data, null, 2));\n}\n\n// Human output (for developers)\nfunction outputHuman(data: any, formatter: (d: any) =\u003e string): void {\n  console.log(formatter(data));\n}\n\n// Auto-select based on --json flag\nfunction output(data: any, formatter?: (d: any) =\u003e string, flags?: GlobalFlags): void {\n  if (flags?.json) outputJson(data);\n  else if (formatter) outputHuman(data, formatter);\n  else console.log(data);\n}\n```\n\n## Error Handling\n- Exit code 0: Success\n- Exit code 1: User error (bad input, missing file)\n- Exit code 2: System error (cass unavailable, API error)\n- Always output errors to stderr","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:19:51.077755-05:00","updated_at":"2025-12-07T16:19:51.077755-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.10","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:19:51.078389-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.10","depends_on_id":"cass_memory_system-5eh.7","type":"blocks","created_at":"2025-12-07T16:20:12.453245-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.10","depends_on_id":"cass_memory_system-5eh.3","type":"blocks","created_at":"2025-12-07T16:20:12.53561-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.11","title":"Init Command: cass-memory init","description":"# Feature: Init Command\n\n## Purpose\nInitialize cass-memory for first-time users:\n1. Create directory structure\n2. Create default config\n3. Create empty playbook\n4. Verify cass availability\n5. Offer to run initial index\n\n## Usage\n```bash\ncass-memory init [--force] [--json]\n```\n\n## Behavior\n```typescript\nasync function initCommand(flags: InitFlags): Promise\u003cvoid\u003e {\n  // 1. Check if already initialized\n  const configExists = await fileExists(\"~/.cass-memory/config.json\");\n  if (configExists \u0026\u0026 !flags.force) {\n    error(\"Already initialized. Use --force to reinitialize.\");\n    return;\n  }\n  \n  // 2. Create directories\n  await ensureDir(\"~/.cass-memory/diary\");\n  await ensureDir(\"~/.cass-memory/reflections\");\n  await ensureDir(\"~/.cass-memory/embeddings\");\n  await ensureDir(\"~/.cass-memory/cost\");\n  \n  // 3. Create default config\n  const config = getDefaultConfig();\n  await saveConfig(config);\n  \n  // 4. Create empty playbook\n  const playbook = createEmptyPlaybook(\"global\");\n  await savePlaybook(playbook, config.playbookPath);\n  \n  // 5. Check cass availability\n  const cassOk = cassAvailable(config.cassPath);\n  if (!cassOk) {\n    warn(\"cass is not available. Some features will not work.\");\n    warn(\"Install cass: https://github.com/your/cass\");\n  }\n  \n  // 6. Output result\n  output({\n    success: true,\n    configPath: expandPath(\"~/.cass-memory/config.json\"),\n    playbookPath: expandPath(config.playbookPath),\n    cassAvailable: cassOk\n  }, formatInitResult, flags);\n}\n```\n\n## Directory Structure Created\n```\n~/.cass-memory/\n├── config.json           # Tool configuration\n├── playbook.yaml         # Global playbook (empty)\n├── diary/                # Diary entries (empty)\n├── reflections/          # Reflection logs\n├── embeddings/           # Embedding cache (Phase 3)\n└── cost/                 # LLM cost tracking\n```\n\n## Output Formats\n\n### JSON (--json)\n```json\n{\n  \"success\": true,\n  \"configPath\": \"/Users/x/.cass-memory/config.json\",\n  \"playbookPath\": \"/Users/x/.cass-memory/playbook.yaml\",\n  \"cassAvailable\": true\n}\n```\n\n### Human-readable\n```\n✓ Created ~/.cass-memory/config.json\n✓ Created ~/.cass-memory/playbook.yaml\n✓ Created directories: diary/, reflections/, embeddings/\n✓ cass available: yes\n\ncass-memory initialized successfully!\n\nNext steps:\n  cass-memory context \"your task\" --json  # Get context for a task\n  cass-memory doctor                       # Check system health\n```","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:19:52.268384-05:00","updated_at":"2025-12-07T16:19:52.268384-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.11","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:19:52.269692-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.11","depends_on_id":"cass_memory_system-5eh.10","type":"blocks","created_at":"2025-12-07T16:20:12.618451-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.11","depends_on_id":"cass_memory_system-5eh.7","type":"blocks","created_at":"2025-12-07T16:20:12.704297-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.11","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:20:12.776772-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.11","depends_on_id":"cass_memory_system-5eh.4","type":"blocks","created_at":"2025-12-07T16:20:12.858635-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.12","title":"Context Command: cass-memory context (P2 - Generator)","description":"# Feature: Context Command (The Generator)\n\n## Purpose\nThe \"Generator\" phase of ACE: retrieve relevant context BEFORE starting a task.\nThis is the primary interface for agents to access accumulated knowledge.\n\n## Usage\n```bash\ncass-memory context \"Fix authentication timeout bug\" --json\ncass-memory context \"Add dark mode support\" --top 10 --days 30\n```\n\n## Process Flow\n```\n1. Parse task description\n2. Generate search keywords (LLM or heuristic)\n3. Score playbook bullets by relevance\n4. Query cass for relevant history\n5. Check deprecated patterns for warnings\n6. Format output (JSON or human)\n```\n\n## Implementation\n```typescript\nasync function contextCommand(task: string, flags: ContextFlags): Promise\u003cvoid\u003e {\n  const config = await loadConfig();\n  const playbook = await loadMergedPlaybook(config);\n  \n  // 1. Extract keywords from task\n  const keywords = extractKeywords(task);\n  \n  // 2. Score and filter bullets\n  const scoredBullets = playbook.bullets\n    .filter(b =\u003e !b.deprecated \u0026\u0026 b.state !== \"retired\")\n    .map(b =\u003e ({\n      ...b,\n      relevanceScore: scoreBulletRelevance(b.content, b.tags, keywords),\n      effectiveScore: getEffectiveScore(b, config)\n    }))\n    .filter(b =\u003e b.relevanceScore \u003e 0)\n    .sort((a, b) =\u003e (b.relevanceScore * b.effectiveScore) - (a.relevanceScore * a.effectiveScore))\n    .slice(0, flags.top || config.maxBulletsInContext);\n  \n  // 3. Query cass for history\n  const cassHits = await safeCassSearch(keywords.join(\" \"), {\n    limit: flags.history || config.maxHistoryInContext,\n    days: flags.days || config.sessionLookbackDays\n  }, config.cassPath);\n  \n  // 4. Check deprecated patterns\n  const warnings = checkDeprecatedPatterns(task, playbook.deprecatedPatterns);\n  \n  // 5. Format output\n  const result: ContextResult = {\n    task,\n    bullets: scoredBullets.map(b =\u003e ({\n      id: b.id,\n      content: b.content,\n      category: b.category,\n      kind: b.kind,\n      relevanceScore: b.relevanceScore,\n      effectiveScore: b.effectiveScore\n    })),\n    history: cassHits,\n    warnings,\n    formattedPrompt: formatContextPrompt(scoredBullets, cassHits, warnings)\n  };\n  \n  output(result, formatContextHuman, flags);\n}\n```\n\n## JSON Output Format (P2)\n```json\n{\n  \"task\": \"Fix authentication timeout bug\",\n  \"bullets\": [\n    {\n      \"id\": \"b-abc123\",\n      \"content\": \"For auth timeout issues, check session TTL in config...\",\n      \"category\": \"debugging\",\n      \"kind\": \"workflow_rule\",\n      \"relevanceScore\": 8.5,\n      \"effectiveScore\": 12.3\n    }\n  ],\n  \"history\": [\n    {\n      \"source_path\": \"~/.claude/sessions/abc.jsonl\",\n      \"line_number\": 142,\n      \"agent\": \"claude\",\n      \"snippet\": \"Fixed auth timeout by increasing session TTL...\",\n      \"score\": 0.85\n    }\n  ],\n  \"warnings\": [\n    \"Deprecated: AuthHandler - use AuthService from @/lib/auth\"\n  ],\n  \"formattedPrompt\": \"## PLAYBOOK CONTEXT\\n...\"\n}\n```\n\n## Human Output Format\n```\n═══════════════════════════════════════════════════════════════\nCONTEXT FOR: Fix authentication timeout bug\n═══════════════════════════════════════════════════════════════\n\nRELEVANT PLAYBOOK RULES (5 bullets):\n\n[b-abc123] debugging/workflow_rule (score: 12.3)\n  For auth timeout issues, check session TTL in config first.\n  Set TTL to match your expected session duration.\n\n[b-def456] debugging/stack_pattern (score: 8.7)\n  When debugging timeouts, enable DEBUG=auth:* for verbose logs.\n\nHISTORICAL CONTEXT (3 sessions):\n\n1. ~/.claude/sessions/abc.jsonl:142 (claude, 2 days ago)\n   \"Fixed auth timeout by increasing session TTL from 3600 to 7200\"\n\n⚠️ WARNINGS:\n  • Deprecated: AuthHandler - use AuthService from @/lib/auth\n\nSUGGESTED SEARCHES:\n  cass search \"auth timeout session\" --days 30\n  cass search \"TTL configuration\" --agent claude\n```","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:19:52.707712-05:00","updated_at":"2025-12-07T16:19:52.707712-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.12","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:19:52.708943-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.12","depends_on_id":"cass_memory_system-5eh.10","type":"blocks","created_at":"2025-12-07T16:20:12.924502-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.12","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:20:13.002126-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.12","depends_on_id":"cass_memory_system-5eh.4","type":"blocks","created_at":"2025-12-07T16:20:13.07105-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.12","depends_on_id":"cass_memory_system-5eh.6","type":"blocks","created_at":"2025-12-07T16:20:13.144343-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.12","depends_on_id":"cass_memory_system-5eh.5","type":"blocks","created_at":"2025-12-07T16:20:13.21074-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.2","title":"Type System: Complete TypeScript Interfaces + Zod Schemas","description":"# Feature: Type System (src/types.ts)\n\n## Purpose\nDefine all TypeScript interfaces and Zod schemas that form the contract for\nthe entire system. This is the most critical file - everything depends on it.\n\n## Key Data Models\n\n### PlaybookBullet (Enhanced)\n```typescript\ninterface PlaybookBullet {\n  // Identity\n  id: string;                    // \"b-{timestamp36}-{random}\"\n  \n  // Scope\n  scope: \"global\" | \"workspace\";\n  workspace?: string;\n  \n  // Content\n  category: string;\n  content: string;               // 10-500 chars\n  searchPointer?: string;        // Optional cass query\n  \n  // Kind (NEW - P14)\n  kind: \"project_convention\" | \"stack_pattern\" | \"workflow_rule\" | \"anti_pattern\";\n  \n  // State Lifecycle (NEW - P10)\n  state: \"draft\" | \"active\" | \"retired\";\n  \n  // Tracking with decay (NEW - P1)\n  feedbackEvents: FeedbackEvent[];  // Timestamped events\n  \n  // Legacy counts (computed from feedbackEvents)\n  helpfulCount: number;\n  harmfulCount: number;\n  \n  // Lifecycle timestamps\n  createdAt: string;\n  updatedAt: string;\n  deprecated: boolean;\n  replacedBy?: string;\n  deprecationReason?: string;\n  \n  // Provenance\n  sourceSessions: string[];\n  sourceAgents: string[];\n  \n  // Tagging\n  tags: string[];\n  \n  // Computed (optional, cached)\n  embedding?: number[];\n}\n```\n\n### FeedbackEvent (NEW - P1)\n```typescript\ninterface FeedbackEvent {\n  type: \"helpful\" | \"harmful\";\n  timestamp: string;              // ISO 8601\n  sessionPath?: string;\n  reason?: string;                // For harmful\n  decayedValue?: number;          // Cached after decay calculation\n}\n```\n\n### DiaryEntry\n- id, sessionPath\n- timestamp, agent, workspace, duration\n- status: success | failure | mixed\n- accomplishments, decisions, challenges, preferences, keyLearnings\n- relatedSessions (cross-agent enrichment)\n- tags, searchAnchors\n\n### Delta Types\n- add, helpful, harmful, replace, deprecate, merge\n\n### Configuration\n- Provider settings (openai/anthropic/google)\n- Path settings (playbookPath, diaryDir)\n- Thresholds (dedup, prune, maxIterations)\n- Feature flags\n\n## Zod Schemas\nAll interfaces must have corresponding Zod schemas for:\n1. Runtime validation\n2. LLM structured output (generateObject)\n3. YAML parsing validation\n\n## Acceptance Criteria\n- All types from plan implemented\n- Zod schemas match interfaces\n- Export all types for use across modules\n- TSDoc comments on complex types","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:17:16.768077-05:00","updated_at":"2025-12-07T16:17:16.768077-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.2","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:17:16.768997-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.2","depends_on_id":"cass_memory_system-5eh.1","type":"blocks","created_at":"2025-12-07T16:20:11.467488-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.3","title":"Utility Functions: src/utils.ts","description":"# Feature: Utility Functions (src/utils.ts)\n\n## Purpose\nShared utility functions used across all modules. Extracted to avoid duplication\nand ensure consistent behavior.\n\n## Function Categories\n\n### Path Utilities\n- `expandPath(p)` - Expand ~ to homedir\n- `ensureDir(dir)` - Create directory recursively\n- `fileExists(path)` - Check file existence\n\n### Content Hashing \u0026 Deduplication\n- `hashContent(content)` - SHA256 hash for content comparison\n- `jaccardSimilarity(a, b)` - Token-based similarity (0-1)\n- `tokenize(text)` - Split text into searchable tokens\n\n### ID Generation\n- `generateBulletId()` - \"b-{timestamp36}-{random}\"\n- `generateDiaryId(sessionPath)` - \"diary-{hash}\"\n\n### Date/Time Utilities\n- `now()` - ISO 8601 timestamp\n- `daysAgo(n)` - Date n days in the past\n- `formatRelativeTime(iso)` - \"2 days ago\", \"3 weeks ago\"\n\n### Text Utilities\n- `extractKeywords(text)` - Extract searchable keywords (stopwords removed)\n- `truncate(text, maxLen)` - Truncate with \"...\"\n\n### Scoring\n- `scoreBulletRelevance(content, tags, keywords)` - Keyword-based relevance score\n\n### Logging\n- `log(msg, verbose)` - Conditional stderr logging\n- `error(msg)` - Error logging to stderr\n\n## Design Decisions\n- All functions are pure where possible\n- No side effects except logging\n- Consistent error handling\n\n## Testing Notes\nThese utilities should have unit tests since they're foundational.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:17:55.017717-05:00","updated_at":"2025-12-07T16:17:55.017717-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.3","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:17:55.018825-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.3","depends_on_id":"cass_memory_system-5eh.2","type":"blocks","created_at":"2025-12-07T16:20:11.552947-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.4","title":"cass Integration Wrapper: src/cass.ts","description":"# Feature: cass Integration Wrapper (src/cass.ts)\n\n## Purpose\nRobust wrapper around the cass CLI for searching, exporting, and managing\nagent session history. Handles errors gracefully with automatic recovery.\n\n## Functions to Implement\n\n### Health \u0026 Availability\n- `cassAvailable(cassPath)` - Check if cass is in PATH\n- `cassNeedsIndex(cassPath)` - Check if index needs rebuild\n\n### Index Management\n- `cassIndex(cassPath, opts)` - Run full or incremental index rebuild\n\n### Search\n- `cassSearch(query, opts, cassPath)` - Execute search, return hits\n- `safeCassSearch(query, opts, cassPath)` - With automatic error recovery\n\n### Export \u0026 View\n- `cassExport(sessionPath, format, cassPath)` - Export session to markdown/json\n- `cassExpand(sessionPath, lineNum, context, cassPath)` - Get context around line\n\n### Stats\n- `cassStats(cassPath)` - Get overall cass statistics\n- `cassTimeline(days, cassPath)` - Get session timeline\n\n## Error Handling (CRITICAL)\nThe cass CLI has specific exit codes that we must handle:\n- 0: success\n- 2: usage_error (non-retryable)\n- 3: index_missing (retryable: rebuild index)\n- 4: not_found (non-retryable)\n- 5: idempotency_mismatch (non-retryable)\n- 9: unknown (non-retryable)\n- 10: timeout (retryable: reduce limit)\n\n## Implementation Details\n- Use execSync for synchronous calls (simpler, avoids callback hell)\n- maxBuffer: 50MB (cass can return large results)\n- Default timeout: 30s per search\n- Always use --robot flag for machine-readable JSON output\n\n## Example Usage\n```typescript\nconst hits = await safeCassSearch(\"authentication error\", {\n  limit: 10,\n  days: 30,\n  agent: [\"claude\", \"cursor\"]\n});\n```","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:17:56.366967-05:00","updated_at":"2025-12-07T16:17:56.366967-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.4","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:17:56.367838-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.4","depends_on_id":"cass_memory_system-5eh.2","type":"blocks","created_at":"2025-12-07T16:20:11.627164-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.4","depends_on_id":"cass_memory_system-5eh.3","type":"blocks","created_at":"2025-12-07T16:20:11.706207-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.5","title":"Secret Sanitization Pipeline (P12 - Security Critical)","description":"# Feature: Secret Sanitization (SECURITY CRITICAL)\n\n## Purpose\nPrevent secrets (API keys, tokens, passwords, private keys) from being stored\nin diary entries, playbook bullets, or any persistent storage.\n\n## Risk Assessment\n- **Impact**: Critical - leaked secrets could compromise systems\n- **Likelihood**: High - agent sessions often contain env vars, configs\n- **Priority**: P12 rated ∞ (security-critical, non-negotiable)\n\n## High-Yield Patterns to Detect\n```typescript\nconst SECRET_PATTERNS = [\n  // AWS\n  { pattern: /AKIA[0-9A-Z]{16}/g, replacement: \"[AWS_ACCESS_KEY]\" },\n  { pattern: /[A-Za-z0-9/+=]{40}(?=\\s|$|\")/g, replacement: \"[AWS_SECRET_KEY]\" },\n  \n  // Generic API keys/tokens\n  { pattern: /Bearer\\s+[A-Za-z0-9\\-\\._~\\+\\/]+=*/g, replacement: \"[BEARER_TOKEN]\" },\n  { pattern: /api[_-]?key[\"\\s:=]+[\"']?[A-Za-z0-9\\-_]{20,}[\"']?/gi, replacement: \"[API_KEY]\" },\n  { pattern: /token[\"\\s:=]+[\"']?[A-Za-z0-9\\-_]{20,}[\"']?/gi, replacement: \"[TOKEN]\" },\n  \n  // Private keys\n  { pattern: /-----BEGIN.*PRIVATE KEY-----[\\s\\S]+?-----END.*PRIVATE KEY-----/g, replacement: \"[PRIVATE_KEY]\" },\n  \n  // Passwords\n  { pattern: /password[\"\\s:=]+[\"'][^\"']{8,}[\"']/gi, replacement: 'password=\"[REDACTED]\"' },\n  \n  // GitHub tokens\n  { pattern: /ghp_[A-Za-z0-9]{36}/g, replacement: \"[GITHUB_PAT]\" },\n  { pattern: /github_pat_[A-Za-z0-9_]{22,}/g, replacement: \"[GITHUB_PAT]\" },\n  \n  // Slack tokens\n  { pattern: /xox[baprs]-[A-Za-z0-9-]+/g, replacement: \"[SLACK_TOKEN]\" },\n  \n  // Database URLs with credentials\n  { pattern: /(postgres|mysql|mongodb):\\/\\/[^:]+:[^@]+@/gi, replacement: \"$1://[USER]:[PASS]@\" }\n];\n```\n\n## Sanitization Points (WHERE to apply)\n1. After cassExport(), before passing to LLM\n2. Before writing DiaryEntry to disk\n3. Before storing content in PlaybookBullet\n4. In context output (already sanitized if stored sanitized)\n\n## Configuration\n```json\n{\n  \"sanitization\": {\n    \"enabled\": true,\n    \"extraPatterns\": [\"INTERNAL_[A-Z_]+_KEY\"]\n  }\n}\n```\n\n## API\n```typescript\nfunction sanitize(text: string, config: SanitizationConfig): string\n```\n\n## Testing Requirements\n- Test each pattern category\n- Test that sanitization is idempotent\n- Test edge cases (partial matches, nested patterns)\n- Verify no false positives on common code patterns","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:17:56.611313-05:00","updated_at":"2025-12-07T16:17:56.611313-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.5","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:17:56.612015-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.5","depends_on_id":"cass_memory_system-5eh.3","type":"blocks","created_at":"2025-12-07T16:20:11.773389-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.6","title":"Confidence Decay + Effective Score Algorithms (P1, P4)","description":"# Feature: Confidence Decay + Effective Score Algorithms\n\n## Purpose\nImplement the highest-ROI feature (20× impact): confidence decay based on\nevent timestamps. Old feedback matters less than recent feedback, preventing\n\"fossilization\" where stale rules persist indefinitely.\n\n## The Problem Being Solved\nWithout decay:\n- A rule marked helpful 50 times 2 years ago stays \"proven\" forever\n- Even if it's now causing problems, its historical weight dominates\n- The playbook becomes fossilized with outdated rules\n\nWith decay:\n- Recent feedback (last 30 days) has full weight\n- Older feedback decays exponentially (half-life: 90 days)\n- Rules must continue proving useful to maintain high scores\n\n## Decay Algorithm\n```typescript\nfunction calculateDecayedValue(\n  event: FeedbackEvent,\n  now: Date,\n  halfLifeDays: number = 90\n): number {\n  const eventDate = new Date(event.timestamp);\n  const ageMs = now.getTime() - eventDate.getTime();\n  const ageDays = ageMs / (1000 * 60 * 60 * 24);\n  \n  // Exponential decay: value = 1 * (0.5)^(age/halfLife)\n  const decayFactor = Math.pow(0.5, ageDays / halfLifeDays);\n  return decayFactor;\n}\n\nfunction getDecayedCounts(bullet: PlaybookBullet, config: Config): {\n  decayedHelpful: number;\n  decayedHarmful: number;\n} {\n  const now = new Date();\n  let decayedHelpful = 0;\n  let decayedHarmful = 0;\n  \n  for (const event of bullet.feedbackEvents) {\n    const decayed = calculateDecayedValue(event, now, config.decayHalfLifeDays);\n    if (event.type === \"helpful\") decayedHelpful += decayed;\n    else decayedHarmful += decayed;\n  }\n  \n  return { decayedHelpful, decayedHarmful };\n}\n```\n\n## Effective Score Algorithm (P4 - 4× harmful multiplier)\n```typescript\nfunction getEffectiveScore(bullet: PlaybookBullet, config: Config): number {\n  const { decayedHelpful, decayedHarmful } = getDecayedCounts(bullet, config);\n  \n  // Key insight: harmful feedback weighs 4× more than helpful\n  // This surfaces problematic rules FAST\n  const rawScore = decayedHelpful - (4 * decayedHarmful);\n  \n  // Maturity multiplier (proven rules get slight boost)\n  const maturityMultiplier = {\n    draft: 0.8,\n    active: 1.0,\n    proven: 1.2,\n    retired: 0.1\n  }[bullet.state] || 1.0;\n  \n  return rawScore * maturityMultiplier;\n}\n```\n\n## Why 4× Harmful Multiplier?\n- A rule that helps 3 times but hurts once is NET NEGATIVE\n- This matches intuition: one bad recommendation erodes trust\n- Forces rules to be consistently helpful, not just occasionally useful\n\n## Maturity State Calculation\n```typescript\nfunction calculateMaturityState(bullet: PlaybookBullet, config: Config): State {\n  const { decayedHelpful, decayedHarmful } = getDecayedCounts(bullet, config);\n  const total = decayedHelpful + decayedHarmful;\n  const harmfulRatio = total \u003e 0 ? decayedHarmful / total : 0;\n  \n  // Transitions\n  if (bullet.deprecated) return \"retired\";\n  if (harmfulRatio \u003e 0.3) return \"retired\";  // Too harmful\n  if (total \u003c 3) return \"draft\";              // Not enough data\n  if (decayedHelpful \u003e= 10 \u0026\u0026 harmfulRatio \u003c 0.1) return \"proven\";\n  return \"active\";\n}\n```\n\n## Configuration\n```json\n{\n  \"scoring\": {\n    \"decayHalfLifeDays\": 90,\n    \"harmfulMultiplier\": 4,\n    \"minFeedbackForActive\": 3,\n    \"minHelpfulForProven\": 10,\n    \"maxHarmfulRatioForProven\": 0.1\n  }\n}\n```","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:18:47.062937-05:00","updated_at":"2025-12-07T16:18:47.062937-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.6","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:18:47.063676-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.6","depends_on_id":"cass_memory_system-5eh.2","type":"blocks","created_at":"2025-12-07T16:20:11.844066-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.7","title":"Configuration Management: Load/Save/Cascade","description":"# Feature: Configuration Management\n\n## Purpose\nHandle configuration loading, saving, and cascading from global to repo-level.\n\n## Configuration Locations (in priority order)\n1. CLI flags (highest priority)\n2. `.cass/config.yaml` (repo-level)\n3. `~/.cass-memory/config.json` (user-level)\n4. Built-in defaults (lowest priority)\n\n## Config Schema\n```typescript\ninterface Config {\n  // Schema version for migrations\n  schema_version: number;\n  \n  // LLM Provider\n  provider: \"openai\" | \"anthropic\" | \"google\";\n  model: string;\n  \n  // Paths\n  playbookPath: string;\n  diaryDir: string;\n  cassPath: string;\n  \n  // Reflection settings\n  maxReflectorIterations: number;  // 1-3\n  dedupSimilarityThreshold: number; // 0.0-1.0\n  pruneHarmfulThreshold: number;    // Auto-prune if harmful \u003e N\n  \n  // Context settings\n  maxBulletsInContext: number;\n  maxHistoryInContext: number;\n  \n  // Scoring settings\n  decayHalfLifeDays: number;\n  harmfulMultiplier: number;\n  \n  // Session settings\n  sessionLookbackDays: number;\n  validationLookbackDays: number;\n  \n  // Feature flags\n  validationEnabled: boolean;\n  autoReflect: boolean;\n  enrichWithCrossAgent: boolean;\n  semanticSearchEnabled: boolean;\n  \n  // Sanitization\n  sanitization: {\n    enabled: boolean;\n    extraPatterns: string[];\n  };\n  \n  // Logging\n  verbose: boolean;\n  jsonOutput: boolean;\n}\n```\n\n## Functions to Implement\n```typescript\n// Load config with cascading priority\nasync function loadConfig(cliOverrides?: Partial\u003cConfig\u003e): Promise\u003cConfig\u003e;\n\n// Save config (only to user-level)\nasync function saveConfig(config: Config): Promise\u003cvoid\u003e;\n\n// Get default config\nfunction getDefaultConfig(): Config;\n\n// Merge configs (used internally)\nfunction mergeConfigs(...configs: Partial\u003cConfig\u003e[]): Config;\n\n// Validate config against schema\nfunction validateConfig(config: unknown): Config;\n```\n\n## YAML Normalization\nAccept both snake_case and camelCase in YAML, always emit camelCase:\n```typescript\nfunction normalizeYamlKeys(obj: any): any {\n  // snake_case → camelCase\n  // e.g., \"helpful_count\" → \"helpfulCount\"\n}\n```","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:18:48.457336-05:00","updated_at":"2025-12-07T16:18:48.457336-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.7","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:18:48.458502-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.7","depends_on_id":"cass_memory_system-5eh.2","type":"blocks","created_at":"2025-12-07T16:20:11.912673-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.7","depends_on_id":"cass_memory_system-5eh.3","type":"blocks","created_at":"2025-12-07T16:20:11.987946-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.8","title":"Playbook YAML Read/Write: src/playbook.ts","description":"# Feature: Playbook YAML Read/Write (src/playbook.ts)\n\n## Purpose\nHandle all playbook operations: loading, saving, creating new playbooks,\nand cascading global + repo-level playbooks.\n\n## Playbook File Format\n```yaml\nschema_version: 2\nname: \"project-playbook\"\ndescription: \"Auto-generated from cass-memory reflections\"\n\nmetadata:\n  createdAt: \"2025-12-01T00:00:00Z\"\n  lastReflection: \"2025-12-07T10:00:00Z\"\n  totalReflections: 42\n  totalSessionsProcessed: 156\n\ndeprecatedPatterns:\n  - pattern: \"AuthHandler\"\n    deprecatedAt: \"2025-10-01\"\n    reason: \"Moved to AuthService v2\"\n    replacement: \"Use AuthService from @/lib/auth\"\n\nbullets:\n  - id: \"b-1a2b3c4d-x7y8\"\n    category: \"testing\"\n    scope: \"global\"\n    kind: \"stack_pattern\"\n    state: \"proven\"\n    content: |\n      For React hooks, test returned values and effects separately\n      using renderHook from @testing-library/react-hooks\n    searchPointer: \"cass search 'react hook testing renderHook'\"\n    feedbackEvents:\n      - type: \"helpful\"\n        timestamp: \"2025-12-05T09:00:00Z\"\n        sessionPath: \"~/.claude/sessions/abc.jsonl\"\n    helpfulCount: 8\n    harmfulCount: 1\n    tags: [\"react\", \"testing\", \"hooks\"]\n    sourceSessions:\n      - \"~/.claude/projects/app/session-001.jsonl:142\"\n    sourceAgents: [\"claude\", \"cursor\"]\n    createdAt: \"2025-11-15T14:30:00Z\"\n    updatedAt: \"2025-12-05T09:00:00Z\"\n```\n\n## Functions to Implement\n```typescript\n// Load single playbook from path\nasync function loadPlaybook(path: string): Promise\u003cPlaybook\u003e;\n\n// Load merged playbook (global + repo)\nasync function loadMergedPlaybook(config: Config): Promise\u003cPlaybook\u003e;\n\n// Save playbook to path\nasync function savePlaybook(playbook: Playbook, path: string): Promise\u003cvoid\u003e;\n\n// Create empty playbook\nfunction createEmptyPlaybook(name?: string): Playbook;\n\n// Merge two playbooks (for cascading)\nfunction mergePlaybooks(global: Playbook, repo: Playbook | null): Playbook;\n\n// Find bullet by ID\nfunction findBullet(playbook: Playbook, id: string): PlaybookBullet | undefined;\n\n// Add bullet to playbook (with dedup check)\nfunction addBullet(playbook: Playbook, bullet: NewBulletData): PlaybookBullet;\n\n// Update bullet\nfunction updateBullet(playbook: Playbook, id: string, updates: Partial\u003cPlaybookBullet\u003e): boolean;\n```\n\n## Cascading Logic (\"Memory as Code\")\nWhen in a git repo with `.cass/playbook.yaml`:\n1. Load global playbook from ~/.cass-memory/playbook.yaml\n2. Load repo playbook from .cass/playbook.yaml\n3. Merge with repo taking precedence for same-ID bullets\n4. Filter out toxic bullets from both levels\n5. Return merged playbook\n\nThis enables \"team brain\" - new developers inherit project rules automatically.\n\n## Toxic Bullet Filtering\n```typescript\nconst globalToxic = await loadToxicLog(\"~/.cass-memory/toxic_bullets.log\");\nconst repoToxic = await loadToxicLog(\"./.cass/toxic.log\");\nmerged.bullets = merged.bullets.filter(b =\u003e\n  !isSemanticallyToxic(b.content, [...globalToxic, ...repoToxic])\n);\n```","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:18:49.646748-05:00","updated_at":"2025-12-07T16:18:49.646748-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.8","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:18:49.647737-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.8","depends_on_id":"cass_memory_system-5eh.2","type":"blocks","created_at":"2025-12-07T16:20:12.059588-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.8","depends_on_id":"cass_memory_system-5eh.3","type":"blocks","created_at":"2025-12-07T16:20:12.142259-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.8","depends_on_id":"cass_memory_system-5eh.6","type":"blocks","created_at":"2025-12-07T16:20:12.210115-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-5eh.9","title":"LLM Provider Abstraction: src/llm.ts","description":"# Feature: LLM Provider Abstraction (src/llm.ts)\n\n## Purpose\nAbstract LLM interactions using Vercel AI SDK, supporting multiple providers\n(OpenAI, Anthropic, Google) with a unified interface.\n\n## Why Vercel AI SDK?\n1. Provider-agnostic: Same code works with any provider\n2. Structured output: generateObject with Zod schemas\n3. Streaming: Built-in support (useful for future MCP server)\n4. Type safety: Full TypeScript support\n\n## Provider Setup\n```typescript\nimport { createOpenAI } from \"@ai-sdk/openai\";\nimport { createAnthropic } from \"@ai-sdk/anthropic\";\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\";\nimport { generateObject, generateText } from \"ai\";\n\nfunction getModel(config: Config) {\n  const apiKey = getApiKeyFromEnv(config.provider);\n  \n  switch (config.provider) {\n    case \"openai\": return createOpenAI({ apiKey })(config.model);\n    case \"anthropic\": return createAnthropic({ apiKey })(config.model);\n    case \"google\": return createGoogleGenerativeAI({ apiKey })(config.model);\n  }\n}\n```\n\n## Environment Variables\n- `OPENAI_API_KEY` for OpenAI\n- `ANTHROPIC_API_KEY` for Anthropic\n- `GOOGLE_GENERATIVE_AI_API_KEY` for Google\n\n## Functions to Implement\n\n### Structured Output (for reflection pipeline)\n```typescript\nasync function extractDiary\u003cT\u003e(\n  schema: z.ZodSchema\u003cT\u003e,\n  sessionContent: string,\n  metadata: SessionMetadata,\n  config: Config\n): Promise\u003cT\u003e;\n\nasync function runReflector\u003cT\u003e(\n  schema: z.ZodSchema\u003cT\u003e,\n  diary: DiaryEntry,\n  existingBullets: string,\n  cassHistory: string,\n  iteration: number,\n  config: Config\n): Promise\u003cT\u003e;\n\nasync function runValidator\u003cT\u003e(\n  schema: z.ZodSchema\u003cT\u003e,\n  proposedRule: string,\n  evidence: string,\n  config: Config\n): Promise\u003cT\u003e;\n```\n\n### Text Generation (for context)\n```typescript\nasync function generateContext(\n  task: string,\n  bullets: string,\n  history: string,\n  deprecatedPatterns: string,\n  config: Config\n): Promise\u003cstring\u003e;\n\nasync function generateSearchQueries(\n  task: string,\n  config: Config\n): Promise\u003cstring[]\u003e;\n```\n\n## Prompt Templates\nDefined in PROMPTS constant:\n- `PROMPTS.diary` - Extract structured diary from session\n- `PROMPTS.reflector` - Generate delta proposals\n- `PROMPTS.validator` - Validate rules against evidence\n- `PROMPTS.context` - Generate pre-task briefing\n- `PROMPTS.audit` - Check session for rule violations\n\n## Error Handling\n- Rate limit handling with exponential backoff\n- Token limit checking before sending\n- Graceful degradation if API unavailable","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-07T16:19:49.140355-05:00","updated_at":"2025-12-07T16:19:49.140355-05:00","dependencies":[{"issue_id":"cass_memory_system-5eh.9","depends_on_id":"cass_memory_system-5eh","type":"parent-child","created_at":"2025-12-07T16:19:49.141377-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.9","depends_on_id":"cass_memory_system-5eh.2","type":"blocks","created_at":"2025-12-07T16:20:12.286016-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-5eh.9","depends_on_id":"cass_memory_system-5eh.7","type":"blocks","created_at":"2025-12-07T16:20:12.369566-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-y8o","title":"Phase 3: Advanced Features + Intelligence","description":"# EPIC: Advanced Features + Intelligence\n\n## Purpose\nAdd intelligent features that dramatically improve relevance and usability:\nlocal semantic search, multi-iteration reflection, scientific validation,\nand playbook health analytics.\n\n## Background \u0026 Reasoning\nSimple keyword matching for bullet relevance achieves ~60% accuracy. By adding\nlocal semantic embeddings via @xenova/transformers (all-MiniLM-L6-v2, 23MB model),\nwe can reach ~90% relevance without network calls.\n\nThe GPT Pro proposal introduced \"scientific validation\" - before accepting a new\nrule, query cass for historical evidence. Did this pattern succeed or fail in the\npast? This prevents accepting rules that contradict historical evidence.\n\nMulti-iteration reflection (from ACE paper) runs the reflector multiple times per\nsession, focusing on different aspects each iteration. This catches insights that\na single pass might miss.\n\n## Priority Features (from ROI analysis)\n- P7: Local semantic search @xenova/transformers (4× impact)\n- P9: Stats command playbook health dashboard (2× impact)\n\n## Key Deliverables\n1. `cass-memory validate \"\u003crule\u003e\"` - Scientific validation against history\n2. `cass-memory stats` - Playbook health dashboard\n3. Local embedding-based relevance scoring\n4. Multi-iteration reflector (configurable 1-3 iterations)\n5. Cross-agent enrichment in diaries\n\n## Technical Specifications\n### Semantic Search\n- Model: Xenova/all-MiniLM-L6-v2 (runs locally, ~23MB)\n- Embedding dimension: 384\n- Scoring: 40% keyword + 60% semantic similarity\n- Cache: ~/.cass-memory/embeddings/bullets.embeddings\n\n### Stats Dashboard Metrics\n- Total bullets by scope (global/workspace)\n- Distribution by maturity (candidate/established/proven/retired)\n- Distribution by kind (project_convention/stack_pattern/workflow_rule/anti_pattern)\n- Top performers (highest effective scores)\n- At-risk bullets (negative effective scores)\n- Stale bullets (no feedback in 90+ days)\n- Merge candidates (high semantic similarity pairs)\n\n## Dependencies\n- Requires Phase 2 completion (diary, reflect, curate pipeline)","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-07T16:16:41.554097-05:00","updated_at":"2025-12-07T16:16:41.554097-05:00","dependencies":[{"issue_id":"cass_memory_system-y8o","depends_on_id":"cass_memory_system-0ew","type":"blocks","created_at":"2025-12-07T16:25:25.218629-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-y8o.1","title":"Validate Command: Scientific Validation (GPT Pro Pattern)","description":"# Feature: Validate Command (Scientific Validation)\n\n## Purpose\nValidate a proposed rule against historical evidence from cass.\nThis implements the GPT Pro proposal's \"scientific validation\" - \ntreating rule proposals as hypotheses to be tested against data.\n\n## Usage\n```bash\ncass-memory validate \"Always use httpx instead of requests\" --json\ncass-memory validate \"Prefer composition over inheritance\" --verbose\n```\n\n## Process Flow\n```\n1. Extract validation keywords from proposed rule\n2. Check evidence-count gate (auto-accept/reject if clear signal)\n3. If ambiguous, run LLM validator with evidence\n4. Return verdict with reasoning\n```\n\n## Implementation\n```typescript\nasync function validateCommand(\n  proposedRule: string,\n  flags: ValidateFlags\n): Promise\u003cvoid\u003e {\n  const config = await loadConfig();\n  \n  // 1. Extract keywords\n  const keywords = extractKeywords(proposedRule);\n  \n  // 2. Check evidence gate\n  const gateResult = await evidenceCountGate(proposedRule, config);\n  \n  if (gateResult.action !== \"needs-llm\") {\n    output({\n      proposedRule,\n      verdict: gateResult.action === \"auto-accept\" ? \"ACCEPT\" : \"REJECT\",\n      confidence: gateResult.confidence,\n      reason: `${gateResult.action}: ${gateResult.successCount} successes, ${gateResult.failureCount} failures`,\n      evidence: gateResult.relevantSessions.map(h =\u003e ({\n        session: h.source_path,\n        snippet: h.snippet,\n        outcome: classifySessionOutcome(h)\n      }))\n    }, formatValidationResult, flags);\n    return;\n  }\n  \n  // 3. Run LLM validator\n  const validation = await runValidator(\n    ValidationResultSchema,\n    proposedRule,\n    formatEvidenceForPrompt(gateResult.relevantSessions),\n    config\n  );\n  \n  output({\n    proposedRule,\n    verdict: validation.valid ? \"ACCEPT\" : \"REJECT\",\n    confidence: validation.confidence || 0.7,\n    reason: validation.reason,\n    refinedRule: validation.refinedContent,\n    evidence: gateResult.relevantSessions.map(h =\u003e ({\n      session: h.source_path,\n      snippet: h.snippet\n    }))\n  }, formatValidationResult, flags);\n}\n```\n\n## Output Example\n```json\n{\n  \"proposedRule\": \"Always use httpx instead of requests\",\n  \"verdict\": \"ACCEPT_WITH_CAUTION\",\n  \"confidence\": 0.75,\n  \"reason\": \"Evidence shows httpx succeeded in 4 sessions for async use cases, but requests was fine for simple sync calls\",\n  \"refinedRule\": \"Prefer httpx for async HTTP calls; requests is acceptable for simple synchronous requests\",\n  \"evidence\": [\n    {\n      \"session\": \"~/.claude/sessions/abc.jsonl\",\n      \"snippet\": \"Switched to httpx for async support, much cleaner code\"\n    },\n    {\n      \"session\": \"~/.cursor/sessions/def.jsonl\", \n      \"snippet\": \"requests worked fine for this simple GET request\"\n    }\n  ]\n}\n```","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:24:14.956313-05:00","updated_at":"2025-12-07T16:24:14.956313-05:00","dependencies":[{"issue_id":"cass_memory_system-y8o.1","depends_on_id":"cass_memory_system-y8o","type":"parent-child","created_at":"2025-12-07T16:24:14.958057-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-y8o.1","depends_on_id":"cass_memory_system-0ew.4","type":"blocks","created_at":"2025-12-07T16:25:25.294018-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-y8o.1","depends_on_id":"cass_memory_system-5eh.9","type":"blocks","created_at":"2025-12-07T16:25:25.373799-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-y8o.2","title":"Stats Command: Playbook Health Dashboard (P9)","description":"# Feature: Stats Command (P9 - Playbook Health Dashboard)\n\n## Purpose\nDisplay comprehensive playbook health metrics. Helps identify:\n- At-risk bullets that need attention\n- Stale bullets that may be outdated\n- Top performers worth promoting\n- Merge candidates (similar content)\n\n## Usage\n```bash\ncass-memory stats\ncass-memory stats --json\ncass-memory stats --category testing\n```\n\n## Metrics Displayed\n\n### 1. Overview\n- Total bullets (global vs workspace)\n- Distribution by state (draft/active/proven/retired)\n- Distribution by kind (project_convention/stack_pattern/workflow_rule/anti_pattern)\n\n### 2. Score Distribution\n- Excellent (effective score \u003e 10)\n- Good (5-10)\n- Neutral (0-5)\n- At Risk (\u003c 0)\n\n### 3. Top Performers\n- Top 5 bullets by effective score\n- Most frequently marked helpful\n\n### 4. Needs Attention\n- Bullets with negative effective scores\n- Stale bullets (no feedback in 90+ days)\n- Merge candidates (similarity \u003e 0.8)\n\n## Implementation\n```typescript\nasync function statsCommand(flags: StatsFlags): Promise\u003cvoid\u003e {\n  const config = await loadConfig();\n  const playbook = await loadMergedPlaybook(config);\n  \n  // Calculate all metrics\n  const stats = {\n    total: playbook.bullets.length,\n    byScope: countByScope(playbook.bullets),\n    byState: countByState(playbook.bullets),\n    byKind: countByKind(playbook.bullets),\n    scoreDistribution: calculateScoreDistribution(playbook.bullets, config),\n    topPerformers: getTopPerformers(playbook.bullets, config, 5),\n    atRisk: getAtRiskBullets(playbook.bullets, config),\n    stale: getStaleBullets(playbook.bullets, 90),\n    mergeCandidates: findMergeCandidates(playbook.bullets, 0.8)\n  };\n  \n  output(stats, formatStatsHuman, flags);\n}\n```\n\n## Human Output\n```\n╭─────────────────────────────────────────────────────────────╮\n│              CASS-MEMORY PLAYBOOK HEALTH                    │\n├─────────────────────────────────────────────────────────────┤\n│ Total Bullets: 156 (Global: 89, Workspace: 67)              │\n│                                                             │\n│ BY STATE:                                                   │\n│   ● Draft:       23 (14.7%)  ░░░░░                          │\n│   ● Active:      87 (55.8%)  ████████████████               │\n│   ● Proven:      34 (21.8%)  ███████                        │\n│   ● Retired:     12 (7.7%)   ███                            │\n│                                                             │\n│ BY KIND:                                                    │\n│   project_convention: 42  stack_pattern: 58                 │\n│   workflow_rule: 48       anti_pattern: 8                   │\n│                                                             │\n│ SCORE DISTRIBUTION:                                         │\n│   Excellent (\u003e10):  18  ████                                │\n│   Good (5-10):      45  ██████████                          │\n│   Neutral (0-5):    71  ████████████████                    │\n│   At Risk (\u003c0):     10  ███  ⚠️                             │\n│                                                             │\n│ TOP PERFORMERS:                                             │\n│   1. b-abc123 (24.3) \"Use waitFor for async assertions...\"  │\n│   2. b-def456 (18.7) \"Prefer httpx for async HTTP...\"       │\n│   3. b-ghi789 (15.2) \"Mock external APIs in tests...\"       │\n│                                                             │\n│ NEEDS ATTENTION:                                            │\n│   ⚠️ 10 bullets at risk (negative scores)                   │\n│   🕐 8 bullets stale (no feedback 90+ days)                 │\n│   🔄 3 merge candidate pairs detected                       │\n╰─────────────────────────────────────────────────────────────╯\n```","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:24:16.21366-05:00","updated_at":"2025-12-07T16:24:16.21366-05:00","dependencies":[{"issue_id":"cass_memory_system-y8o.2","depends_on_id":"cass_memory_system-y8o","type":"parent-child","created_at":"2025-12-07T16:24:16.214832-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-y8o.2","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:25:25.45307-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-y8o.2","depends_on_id":"cass_memory_system-5eh.6","type":"blocks","created_at":"2025-12-07T16:25:25.523207-05:00","created_by":"daemon"}]}
{"id":"cass_memory_system-y8o.3","title":"Local Semantic Search: @xenova/transformers (P7)","description":"# Feature: Local Semantic Search (P7 - 4× Relevance Impact)\n\n## Purpose\nDramatically improve bullet relevance matching by using local semantic\nembeddings. Catches synonyms and conceptual matches that keyword search misses.\n\n## The Problem\nKeyword matching misses:\n- \"authentication\" vs \"auth\" vs \"login\" vs \"session\"\n- \"error handling\" vs \"exception management\" vs \"failure recovery\"\n- \"performance optimization\" vs \"speed improvement\" vs \"making it faster\"\n\n## Solution: Local Embeddings\nUse @xenova/transformers with all-MiniLM-L6-v2 model:\n- Runs 100% locally (no network calls)\n- ~23MB model download (one time)\n- ~3ms per embedding on modern laptop\n- 384-dimension dense vectors\n\n## Implementation\n```typescript\nimport { pipeline } from \"@xenova/transformers\";\n\nlet embedder: any = null;\n\nasync function getEmbedder() {\n  if (!embedder) {\n    embedder = await pipeline(\n      \"feature-extraction\",\n      \"Xenova/all-MiniLM-L6-v2\"\n    );\n  }\n  return embedder;\n}\n\nasync function embedText(text: string): Promise\u003cnumber[]\u003e {\n  const embed = await getEmbedder();\n  const result = await embed(text, { pooling: \"mean\", normalize: true });\n  return Array.from(result.data);\n}\n\nfunction cosineSimilarity(a: number[], b: number[]): number {\n  let dot = 0, normA = 0, normB = 0;\n  for (let i = 0; i \u003c a.length; i++) {\n    dot += a[i] * b[i];\n    normA += a[i] * a[i];\n    normB += b[i] * b[i];\n  }\n  return dot / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n```\n\n## Enhanced Bullet Scoring\n```typescript\nasync function scoreBulletsEnhanced(\n  bullets: PlaybookBullet[],\n  task: string,\n  config: Config\n): Promise\u003cScoredBullet[]\u003e {\n  // 1. Keyword scoring (fast, always run)\n  const keywords = extractKeywords(task);\n  const keywordScored = bullets.map(b =\u003e ({\n    bullet: b,\n    keywordScore: scoreBulletRelevance(b.content, b.tags, keywords)\n  }));\n  \n  // 2. Semantic scoring (if enabled)\n  if (!config.semanticSearchEnabled) {\n    return keywordScored.map(({ bullet, keywordScore }) =\u003e ({\n      ...bullet,\n      combinedScore: keywordScore,\n      effectiveScore: getEffectiveScore(bullet, config)\n    }));\n  }\n  \n  const taskEmbedding = await embedText(task);\n  \n  const semanticScored = await Promise.all(\n    keywordScored.map(async ({ bullet, keywordScore }) =\u003e {\n      // Load cached or compute embedding\n      const bulletEmbedding = bullet.embedding || await embedText(bullet.content);\n      const semanticScore = cosineSimilarity(taskEmbedding, bulletEmbedding);\n      \n      return {\n        ...bullet,\n        keywordScore,\n        semanticScore,\n        // Combined: 40% keyword + 60% semantic\n        combinedScore: (keywordScore * 0.4) + (semanticScore * 10 * 0.6),\n        effectiveScore: getEffectiveScore(bullet, config)\n      };\n    })\n  );\n  \n  return semanticScored;\n}\n```\n\n## Embedding Cache\n```typescript\n// ~/.cass-memory/embeddings/bullets.json\ninterface EmbeddingCache {\n  version: string;\n  model: string;\n  bullets: Record\u003cstring, {\n    contentHash: string;\n    embedding: number[];\n    computedAt: string;\n  }\u003e;\n}\n\nasync function loadOrComputeEmbeddings(\n  playbook: Playbook,\n  cache: EmbeddingCache\n): Promise\u003cvoid\u003e {\n  for (const bullet of playbook.bullets) {\n    const hash = hashContent(bullet.content);\n    const cached = cache.bullets[bullet.id];\n    \n    if (cached \u0026\u0026 cached.contentHash === hash) {\n      bullet.embedding = cached.embedding;\n    } else {\n      bullet.embedding = await embedText(bullet.content);\n      cache.bullets[bullet.id] = {\n        contentHash: hash,\n        embedding: bullet.embedding,\n        computedAt: now()\n      };\n    }\n  }\n  await saveEmbeddingCache(cache);\n}\n```\n\n## Performance Characteristics\n- Model download: ~23MB (first use only)\n- Model load: ~500ms (first embedding only)\n- Per-embedding: ~3ms\n- 100 bullets: ~300ms total\n- Cache hit: ~0ms (just array lookup)","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:24:17.511923-05:00","updated_at":"2025-12-07T16:24:17.511923-05:00","dependencies":[{"issue_id":"cass_memory_system-y8o.3","depends_on_id":"cass_memory_system-y8o","type":"parent-child","created_at":"2025-12-07T16:24:17.513127-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-y8o.3","depends_on_id":"cass_memory_system-5eh.3","type":"blocks","created_at":"2025-12-07T16:25:25.607173-05:00","created_by":"daemon"},{"issue_id":"cass_memory_system-y8o.3","depends_on_id":"cass_memory_system-5eh.8","type":"blocks","created_at":"2025-12-07T16:25:25.68334-05:00","created_by":"daemon"}]}
